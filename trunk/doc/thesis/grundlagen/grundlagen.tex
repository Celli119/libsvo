\chapter{Grundlagen}


\section{Volumendaten}
Volumendaten können durch dreidimensionale, äquidistante Gitter beschrieben werden. Die Kreuzungspunkte des Gitters werden \textit Voxel (Volumen-Pixel) genannt. Jeder Voxel kann einen einzelnen skalaren Wert, wie beispielsweise Dichte oder Druck, oder mehrere skalare Werte wie Farbe in Kombination mit Richtungsinformationen enthalten. Dadurch eignet sich diese Darstellung zur Repräsentation eines äquidistant gesampelten Raumes, der nicht homogen gefüllt ist. Durch die uniforme Unterteilung des Raumes ist die Position und die Ausdehnung eines jeden Voxels implizit in der Datenstruktur enthalten und muss daher nicht gespeichert werden.\\
Volumendaten werden vorwiegend in der Medizin, beispielsweise als Ausgabe der Magnetresonanztomographie oder in der Geologie zum Abbilden der Ergebnisse von Reflexionsseismikverfahren verwendet.\\
Um eine hinreichende Auflösung der Volumenrepräsentation zu gewährleisten sind große Datenmengen erforderlich. Ein mit $512^3$ Voxeln aufgelöstes Volumen, dessen Voxel jeweils einen mit 4 Byte abgebildeten Skalar enthalten, belegt bereits 512 Megabyte. Verdoppelt man die Auflösung auf $1024^3$ verachtfacht sich der Speicherbedarf auf 4 Gigabyte. Allerdings enthalten Volumendaten in der Regel einen großen Anteil an homogenen Bereichen, die jedoch durch ein reguläres Gitter als viele Einzelwerte abgebildet werden müssen. Daher gibt es Datenstrukturen die ausgehend von dem regulären Gitter eine hierarchische Struktur erzeugen um diese Bereiche zusammenzufassen.


\section{Octrees}
Ein Octree ist eine raumteilende, rekursive Datenstruktur. Ein initiales, kubisches Volumen wird in acht gleich große Untervolumen geteilt. Die Teilung wird für jedes Untervolumen fortgeführt, bis eine maximale Tiefe beziehungs\-weise ein maximaler Unterteilunggrad erreicht ist. Mit jeder Tiefen\-stufe des Octrees verdoppelt sich die Auflösung der abbildbaren Information auf jeder Achse. Die Größe eines Voxels kann mit $ 2^{-d} $ bestimmt werden wobei $d$ die Tiefe des Voxels in der Baumstruktur, beginnend mit $d=0$ für die Wurzel, ist. Für vollbesetzte Octrees ist eine Darstellung im Speicher implizit vorgegeben. Da jeder Elternknoten genau acht Kinder besitzt kann durch seine Position in einer angenommenen, seriellen Struktur implizit auf seine Kind\-knoten geschlossen werden. Dabei kann die Position jedes Kindes eines Knotens durch $ C(P,n) = 8*P+n $ berechnet werden (!!!BILD) wobei $P$ die Position des Elternknotens, $n$ die Nummer des Kindes (beginnend mit 1) und das resultierende $C$ die Position des Kindknotens ist.\\
Bereiche, die homogene Daten enthalten oder leer sind, können jedoch von der Unterteilung ausgeschlossen werden, wodurch eine wesentlich kompaktere Darstellung der Daten gegenüber konventionellen Volumendaten erreicht werden kann. Für jedes Volumen/Voxel muss dann ein Verweis auf die ihn unterteilenden Untervolumen existieren. In der Regel besitzt jeder Voxel eines solchen Octrees acht Kinder (\textit{innerer Knoten}) oder kein Kind (\textit{Blatt-Knoten}). Die, im ungünstigsten Fall zu speichernden sieben leeren Knoten, sind bei dieser Darstellung nötig, um homogene Bereiche innerhalb des Eltern-Voxels zu kodieren.\\
Jeder Voxel kann ein oder mehrere Skalare speichern. Oft werden diese Werte nicht direkt im Octree abgelegt um bei die Traversierung der Struktur möglichst wenig Speicher lesen zu müssen. Stattdessen werden die Attributinformation in einem zusätzlichen Attribut-Buffer abgelegt, in dem zu jeder Voxel-Position im Octree ein Tuple mit Attributinformation an der selben Stelle im Attribut-Buffer vorgehalten wird. Die Attribute eines übergeordneten Voxels ergeben sich dabei im einfachsten Fall aus dem Mittel der Attribute seiner untergeordneten Voxel, vergleichbar mit der Erzeugung von \textit{Mipmaps}. Somit enthält jeder Voxel einen seiner Größe entsprechend Detailgrad an Attributinformation. Der wesentliche Vorteil des Octrees gegenüber texturierten Dreiecksnetzen ist somit, das die Datenstruktur das LOD-Problem nicht nur für Attribute (Texturen), sondern auch für Geometrie löst. Der Octree ist also beides: Geometrie und Textur.


\section{Sparse Octrees}
Für einige Anwendungen sind nur bestimmte Ausprägungen der in den Voxeln gespeicherten Werte von Interesse. Beispielsweise werden beim Iso-Surface-Rendering nur Voxel mit einem bestimmten Dichtewert als opake Oberfläche dargestellt. Ist dies der Fall kann die Datenstruktur weiter ausgedünnt werden, in dem nur noch Voxel gespeichert werden die zur Oberfläche beitragen. Somit können innere Knoten weniger als acht Kinder haben. Eine solche ~Volumenrepräsentation eignet sich ebenso zur Darstellung anderer opaker Oberflächen wie diskretisierte Dreiecksnetze, Punktwolken oder Höhenfelder und wird als Sparse Octree oder Sparse Voxel Octree bezeichnet. Durch die variierende Anzahl von Kindknoten existiert keine implizite Regel zum berechnen deren Positionen. Vielmehr muss jeder Knoten speichern welche Kindknoten vorhanden sind und wo sich diese im Speicher befinden. Liegen die Kindknoten jedes Voxels jeweils hintereinander im Speicher muss nur ein Verweis pro Elternknoten vorgehalten werden.\\
Da in Sparse-Voxel-Octrees nur Oberflächen gespeichert werden steigt der Speicherbedarf pro weiterer Tiefenstufe nur durchschnittlich um das vierfache (vgl. ESVORG)


\section{Raycasting}











