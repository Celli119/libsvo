\chapter{Erstellung der SVO-Struktur}

\section{Generalisiertes System zur SVO-Erstellung}
Das System zur Erstellung der SVO-Struktur ist modular aufgebaut und besteht prinzipiell aus drei Teilen: Dem \textbf{\textit{Build-Manager}} der den Ablauf der SVO-Generierung steuert, einem \textbf{\textit{Treelet-Builder}} der die Treelets erstellt und abhängig vom Typ der Eingabedaten gewählt wird und einem \textbf{\textit{Attributgenerator}} der Abhängig von Eingabedaten und gewünschter Attributkonfiguration der Ausgabedaten gewählt werden kann. Mit dieser Unterteilung des Systems ist es prinzipiell möglich verschiedenste Eingabedaten wie 3D-Objekte aus Dreiecksnetzen oder Punktwolken zu verarbeiten und eine Vielzahl von Attributtkonfigurationen zu erstellen. Durch den modularen Aufbau und der Bereitstellung entsprechender Basisklassen ist es möglich Unterstützung für weitere Eingabeformate zu schaffen.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{erstellung_der_svo_struktur/figures/uml.pdf}
  \caption{Klassendiagram des generallisierten Erstellungssystems \label{uml_diagam}}
\end{figure}
Das in Abbildung \ref{uml_diagam} abgebildete Klassen\-diagramm zeigt die Relationen zwischen den einzelnen Komponenten. Der Build-Manager besitzt einen Treelet-Builder der Abhängig von der Art der Eingabedaten gewählt wird. Dazu besitzt er einen passenden Attributgenerator der anhand der Eingabedaten und SVO-Repräsentation Attribute für alle Knoten erzeugt.


\section{Erzeugung der Treelet Struktur}\label{sec:erzeugung_treelet_struktur}
Die SVO-Struktur wird schon bei der Erstellung segmentiert, das heißt, in Treelets unterteilt aufgebaut. Dies bietet die Möglichkeit bereits erzeugte Treelets auf die Festplatte auszulagern, sollte der Ar\-beits\-speicher nicht ausreichen um die erzeugten Daten zu halten. Im Folgendem soll ein Überblick über den Ablauf der Erstellung einer SVO-Struktur aus Treelets gegeben werden. In den folgenden Abschnitten werden die einzelnen Schritte genauer betrachtet.\\\\
Als Eingabe werden zunächst die gewünschte, minimale Tiefe des resultierenden Octrees, die Speichergröße der Treelets und der Pfad zu den Eingabedaten benötigt. Der Build-Manager erstellt ein initiales, leeres Treelet (\textit{Wurzel-Treelet}) und übergibt dieses an den Treelet-Builder. Dieser füllt das Treelet anhand der Eingabedaten. Anschließend werden alle entstandenen Blatt-Knoten, die noch nicht die gewünschte, minimale Tiefe in der Octree-Struktur aufweisen, notiert. Zu jedem dieser Blattknoten wird eine Liste der in ihm liegenden Primitive der Eingabedaten gespeichert. Zusätzlich wird auch seine Tiefe im Baum und seine Transformation relativ zum Wurzelknoten notiert. Außerdem wird jeweils der Treelet-Index, der Index des Blattknotens und dessen Elternknotens gespeichert um die Verknüpfung der Treelets realisieren zu können (vgl. Abschnitt \ref{sec:segmentierung} \nameref{sec:segmentierung}, Seite \pageref{sec:segmentierung}).
Der Build-Manager speichert diese Informationen in einer Queue und erzeugt für jeden Eintrag ein neues Treelet (\textit{Top-Down}). Diese werden durch die gespeicherten Treelet- und Blattknotenindices des Wurzel-Treelets initialisiert und sind so logisch mit diesem verbunden. Jedes dieser Treelets wird wiederum dem Treelet-Builder übergeben, der sie anhand seiner Primitivliste und der gespeicherten Transformation füllt. Der Build-Manager erzeugt sukzessiv weitere Treelets aus Blattknoten bereits erstellter Treelets bis die geforderte minimale Tiefe des Octrees für alle Blattknoten erreicht ist.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.83\textwidth]{erstellung_der_svo_struktur/figures/treelet_building.pdf}
  \caption{Schrittweiser Aufbau der SVO-Struktur aus Treelets \label{fig:treelet_building}}
\end{figure}
\newpage
Für Blattknoten mit ausreichender Tiefe erzeugt ein Attributgenerator die gewünschten Attribute und speichert diese in einem zusätzlichen Buffer. Die Primitiv\-liste und alle weiteren Informationen die zur Erstellung weiterer Treelets benötigt würden können an dieser Stelle verworfen werden. Abbildung \ref{fig:treelet_building} zeigt den schrittweisen Aufbau eines Octrees aus Treelets.\\
Ist die Erstellung der Treelets abgeschlossen werden die Attribute der inneren Knoten durch Mitteln der Attribute ihrer Untergeordneten Knoten erstellt. Dies geschiet für alle Treelets in umgekehrter Reihenfolge ihrer Erstellung (\textit{Bottom-Up}). So wird sichergestellt, dass der Wurzelknoten eines Untergeordneten Treelets bereits Attributinformation enthält wenn sein Übergeordnetes Treelet diese zur Generierung seiner Attribute in seinen Blattknoten benötigt. Ist die Erstellung der Attribute bis in den Wurzelknoten des Wurzel-Treelets vorangeschritten ist die Erstellung des Octrees abgeschlossen. 

\newpage
\section{Arbeitsweise des Treelet-Builders}
Der Treelet-Builder erstellt die Knoten in der Breite (\textit{Breadth-First}) und arbeitet dazu intern auf einem FIFO-Kontainer (\textit{Queue}). Der Aufbau eines Elementes dieser Queue ist im Listing \ref{lst:queueelement} zu sehen. Jedes Element der Queue entspricht einem Knoten in der SVO-Struktur und enthält einerseits alle Informationen die nötig sind diesen Knoten seinem übergeordneten Knoten mitzuteilen und andererseits die Erzeugung weiterer Unterknoten zu ermöglichen.

%\begin{figure}[position=h width=0.75\textwidth]
%  \centering
\begin{lstlisting}[caption={Queue-Element},label={lst:queueelement}]
struct QueueElement
{
  // Knoten-Index des Knotens innerhalb des Treelets
  unsigned              _localLeafIndex;         
  // Kind-Index des Knotens innerhalb seines Eltern-Knotens
  char                  _idx;                    
  // Knoten-Index des Eltern-Knotens
  unsigned              _parentLocalNodeIndex;   
  // Tiefe des Knotens in der SVO-Struktur
  unsigned              _depth;                  
  // Transformation des Knotens relativ zum Wurzelknoten
  gloost::Matrix        _aabbTransform;          
  // In diesem Knoten enthaltene Primitive der Ausgangsdaten
  std::vector<unsigned> _primitiveIds;           
};
\end{lstlisting}
%\end{figure}
Initial wird ein Queue-Element stellvertretend für den Wurzelknoten des aktuellen Treelets erstellt. Dieses enhält die relative Transformation dieses Knotens in der SVO-Struktur sowie alle Primitive die in diesen Knoten liegen. Für jeden potentiellen Kind-Knoten wird ein Queue-Element mit entsprechenden Parametern erzeugt und dessen \textit{Bounding Box} mit  Primitiven des aktuellen Queue-Elementes zum Schnitt gebracht. Dabei wird für jedes Kind die Untermenge an Primitiven notiert die geschnitten wurden. Falls ein Kindknoten keine Primitive enthält, wird es verworfen. Die anderen Kindknoten bekommen aufeinanderfolgende Speicherpositionen innerhalb des Treelets. Der \textit{First-Child-Index} des Knotens des aktuellen Queue-Elementes wird daraufhin auf die Position des ersten Kindes gesetzt und die Queue-Elemente der Kindknoten in die Queue eingereiht.\\
Vor dem Abarbeiten eines Queue-Elementes wird überprüft, ob im Treelt noch genügend freier Plätze für eine weitere Unterteilung vorhanden ist. Sind weniger als acht Plätze übrig muss nach der nächsten Unterteilung erst überprüft werden, ob die entstanden Kindknoten noch abgelegt werden können, bevor die Unterteilung gespeichert werden kann.  Geht dies nicht, wird versucht einen Queue-Element zu finden, dessen Bearbeitung weniger neue Knoten erzeugt. Kann kein Queue-Element gefunden werden, ist die Erstellung des Treelets abgeschlossen.\\
Die in der Queue verbliebenen Elemente werden nach ihrer Baumtiefe in finale und weiter zu unterteilende Elemente getrennt und in zwei Kontainern im Treelet gespeichert. Nachdem die finalen Knoten in den Leaf-Masks der Eltern-Knoten als solche markiert wurden, wird das Treelet an den Build-Manager zurückgegeben.\\\\
Der Build-Manager erzeugt für jedes nicht finale Queue-Element ein weiteres Treelet. Der Indices der neu erstellten Treelets werden im \textit{First-Child-Index} der zugehörigen Blattknoten des übergeordneten Treelets gespeichert. Dann werden die Treelets entsprechned parametrisiert in einer eigenen Queue eingereiht um sie in entsprechender Reihenvolge an den Treelet-Builder weitergeben zu können. Der oben beschriebene Ablauf wiederholt sich daraufhin für jedes Treelet in der Queue. Liefert der Treelet-Builder nur noch Treelets mit finalen Blattknoten, leert sich die Queue und das Erstellen der SVO-Struktur ist abgeschlossen. 


\section{Attribut-Generation}
Zu jedem Treelet werden parallel ein oder mehrere Buffer mit verschachtelten (\textit{interleaved}) Attributinformationen erstellt. Anzahl und Layout der Attribut-Buffer sind abhängig vom gewählten Attribut-Generator.\\
Für jeden finalen Blattknoten wird mit Hilfe der gespeicherten Primitive und Transformation eine Menge von Attributen erzeugt. Dieser Vorgang soll im Folgenden am Beispiel von Dreiecks\-primitiven erläutert werden. Für jedes Dreieck innerhalb eines Blatt-Knotens wird ein Strahl erzeugt, der durch die Voxel\-mitte und senkrecht zum Dreieck verläuft. Der Strahl wird mit den Dreiecken geschnitten um so eine UV-Koordinate berechnen zu können.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.85\textwidth]{erstellung_der_svo_struktur/figures/voxel_primitiv_schnitt.pdf}
  \caption{Ermittlung von UV-Koordinaten\label{voxel_primitiv_schnitt}}
\end{figure}
Durch die Wahl der Richtung ist gewährleistet, dass der Winkel zwischen Strahl und Dreicks\-normale maximal ist, so dass die Wahrscheinlichkeit eines Schnittes erhöht wird. Trotzdem ist es möglich, dass der Strahl das Dreieck verfehlt, da das Voxel das Dreieck bei\-spiels\-weise nur mit einer Ecke schneidet, die nicht zur Voxel-Mitte ausgerichtet ist. In diesem Fall wird der Punkt auf dem Dreieck als Schnittpunkt angenommen, der den kleinsten Abstand zum Schnittpunkt mit der Dreiecksebene besitzt. Dieser Vorgang erzeugt ein Rauschen in den Daten das aber angesichts der geringen Größe der Blatt-Knoten und des daraus resultierenden geringen Fehlers nicht sichtbar ist. Mit Hilfe der ermittelten UV-Koordinaten können nun Attribute wie Farbe oder Richtung aus den Eckpunkten der Dreiecke interpoliert oder aus Texturen gelesen werden. Die erhaltenen Werte werden über alle am Voxel beteiligten Dreiecke gemittelt. Farb- und Richtungs\-werte werden auf 8 Bit pro Komponente quantisiert bevor sie in den Attributbuffer gespeichert werden.\\
\newpage
Wie in Abschnitt \ref{sec:erzeugung_treelet_struktur} angedeutet, werden die Attribute der inneren Knoten erst erzeugt, nachdem die Erstellung aller Treelets ab\-ge\-schlos\-sen ist. Durch die Verwendung eines FIFO-Kontainers im Build-Manager sind die Treelets so nummeriert, dass jedes Treelet einen niedrigeren Index besitzt als seine untergeordneten Treelets. Somit ist das Treelet mit dem höchsten Index von keinem anderen Treelet für die Generierung seiner Attribute abhängig, da es schon in allen seinen Blatt-Knoten Attribute besitzt. Das Treelet mit dem Index $0$ ist dagegen für seine Attributgenerierung von allen anderen Treelets abhängig. Für die Generierung der Attribute werden die Treelets daher in umgekehrter Reihenfolge ihrer Indizierung abgearbeitet. Abbildung \ref{attribute_generation} veranschaulicht die Reihenfolge anhand eines Beispiels (vgl. Abbildung \ref{fig:treelet_building}).
\begin{figure}[position=v]
  \centering
  \includegraphics[width=0.70\textwidth]{erstellung_der_svo_struktur/figures/attribute_generation.pdf}
  \caption{Reihenfolge der Erzeugung der Attributen innerer Knoten\label{attribute_generation}}
\end{figure}\\
Beginnend beim Treelet mit dem größten Index wird jedes Treelet, vom Wurzelknoten an, der Tiefe nach, rekursiv durchlaufen bis die Blattknoten erreicht werden. Diese enthalten bereits Attribute\-informationen. Beim Aufsteigen aus der Rekursion werden die Attribute der jeweils vorhandenen Kindknoten gemittelt und im Attribut-Buffer abgelegt. Dazu werden die gelesenen, mit 8 Bit  aufgelösten Attribut\-komponenten zunächst wieder in 32 Bit Fließ\-komma\-werte konvertiert, damit sich bei der Mittelung der Kindknotenattribute die Quantisierungsfehler nicht verstärken. Nachdem auch für den Wurzelknoten ein Attribut vorhanden ist, wird dieses in den Attribut-Buffer des übergeordneten Treelets für den entsprechenden Blattknoten abgelegt. Durch die Reihenfolge der Indizierung ist für jedes Treelet sichergestellt, dass für alle Blatt\-knoten Attributinformationen vorhanden sind wenn sie zur Generierung der Attribute der inneren Knoten benötigt werden.






