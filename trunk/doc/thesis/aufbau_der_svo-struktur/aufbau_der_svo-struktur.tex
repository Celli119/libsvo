\chapter{Aufbau der SVO-Stuktur}

\section{Definition der Knoten-Struktur}
Die Octree-Struktur in dieser Arbeit ist so aufgebaut, das jeder Knoten im Baum einen Voxel repräsentiert. Jeder Voxel steht für einen achsen\-paralleler Würfel der die Oberfläche der abzubildenden Geometry schneidet. Jeder Voxel kann in bis zu acht weitere Voxel unterteilt werden. Die Indizierung der Kind-Voxel ergibt sich aus ihrer Position innerhalb des Eltern-Voxels. Diese kann durch die Vorschrift \textbf{$i(x,y,z)=4p(x)+2p(y)+p(z)$} bestimmt werden, wobei $p(x)$, $p(y)$ und $p(z)$ für die Ergebnisse der Aussagen $x>0$, $y>0$ und $z>0$ stehen. Abbildung \ref{voxel_idx} zeigt eine vollständig unterteilten Voxel und die Indizierung seiner Kind-Voxel.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.35\textwidth]{aufbau_der_svo-struktur/figures/voxel_idx.pdf}
  \caption{Indizierung der Kind-Voxel\label{voxel_idx}}
\end{figure}\\
Die Topologie des Octrees wird durch 64 Bit große Knoten beschrieben. Der Speicherbedarf teilt sich in 32 Bit für den Verweis auf das erste Kind (\textbf{\textit{First-Child-Index}}) und zwei Bitmasken, die jeweils 8 Bit beanspruchen. Eine Bitmaske kodiert in jedem Bit das jeweilige Vorhandensein eines Kindes (\textbf{\textit{Valid-Mask}}). Die zweite Bitmaske kodiert in jedem Bit ob das jeweilige Kind ein Blatt ist oder nicht (\textbf{\textit{Leaf-Mask}}). Abbildung \ref{node_struktur} veranschaulicht den Aufbau der Baumstruktur durch diese Knoten\-repräsentation. 
16 Bit pro Knoten bleiben für die Anwendung in dieser Arbeit frei, können aber auf verschiedene weise genutzt werden. Beispielsweise ist es möglich diesen Platz zum Speichern von Attributen oder Verweisen zu Kontur\-informationen zu nutzen, wie es in (ESVOR) getan wird. Der freie Platz ist mit den Anforderungen an minimale Speichergrößen und Segmentierung der OpenCL zu erklären, die keine 24 oder 48 Bit Datentypen definiert. Lösungsvorschläge für eine kompaktere Notation werden in ( !!! verweis auf verbesserungen) diskutiert.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.55\textwidth]{aufbau_der_svo-struktur/figures/node_memory.pdf}
  \caption{Aufbau eines Knotens\label{node_memory}}
\end{figure}
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.55\textwidth]{aufbau_der_svo-struktur/figures/node_struktur.pdf}
  \caption{Beschreibung der SVO-Struktur\label{node_struktur}}
\end{figure}

\newpage



\section{Segmentierung}\label{sec:segmentierung}

\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{aufbau_der_svo-struktur/figures/treelet_struktur.pdf}
  \caption{Treelet-Struktur mit 6 Knoten pro Treelet \label{treelet_struktur}}
\end{figure}
Die Unterteilung der SVO-Struktur erfolgt in Unterbäumen die in dieser Arbeit als \textit{Treelets} (Bäumchen) bezeichnet werden. Jedes Treelet umfasst die selbe Anzahl an Knoten und stellt für sich gesehen einen Sparse Voxel Octree, mit Wurzel- und Blatt\-knoten dar (vgl. Abbildung \ref{treelet_struktur}). Zum identifizieren eines Treelets erhält jedes einen eindeutigen Index (\textit{Treelet-Index}). Über diesen wird die Verknüpfung der Treelets untereinander realisiert. Dazu speichert jedes Treelet den Index des seines übergeordnet Treelets und die Position des jeweiligen Blattknotens.
Die im Baum abwärts gerichtete Verknüpfung wird durch Speichern der Indices der untergeordneten Treelets im First-Child-Index des je\-wei\-ligen Blattknotes realisiert.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.90\textwidth]{aufbau_der_svo-struktur/figures/verbinung_ueber_treelet_index.pdf}
  \caption{Verbindung der Treeelets durch ihren Index \label{verbinung_treelet_index}}
\end{figure}
Die Verbindung der Treelts untereinander bildet einen bidirektionalen Baum über dem eigentlichen Octree. Abbildung \ref{verbinung_treelet_index} stellt diese Verbindung dar. Unter der Abbildung des Baumes sind Werte der First-Child-Pointer für alle Knoten notiert.\\
Durch die abwärts gerichtete Verbindung, die in den Blatt-Knoten gespeichert ist kann beim Traversieren der Struktur in jedem Blatt das zugehörige Treelet ermittelt werden um dieses bei Bedarf anzufordern. Die aufwärts gerichtete Verbindung ermöglicht den effizienten Zugriff auf alle übergeordneten Treelets bis zum Wurzel-Treelet von denen ein gegebenes Treelet für seine Verarbeitung in der SVO-Struktur abhängig ist.
\newline
Die Speichergröße der Treelets kann bei der Erstellung des Baumes angegeben werden. Für die Tests in diese Arbeit wurden Größen zwischen einem und zehn Kilobyte gewählt. Dabei gilt es bei der Wahl der Speichergröße zwischen Granularität und Aufwand abzuwägen  Um eine hohe Granularität und damit eine hohe Anpassung der gewählten Untermenge an Segmenten zu gewährleisten, sollte die Größe der Treelets eher klein gewählt werden. Sind die Treelets jedoch zu klein können für einen gegebenen Octree schnell mehrere Millionen Treelets entstehen. Deshalb ist es nötig für jeden als Treelet-Struktur abzubildende Datensatz eine geeignete Treelet-Größe zu wählen.


\section{Attribute}\label{sec:attribute}
Attributinformationen werden parallel zu den Treelets in einem oder mehreren Attribut-Buffern gehalten. Diese Buffer können sehr groß werden, da benötigten Attributwerte für jeden Voxel des Octrees einzeln gespeichert werden. Darum werden die Werte, z.B. Beleuchtungsinformationen wie Farben, Richtungsinformationen oder ambiente Verdeckungswerte (Ambient Occlusion) vor dem Ablegen komprimiert. Dies kann durch die Verwendung von 8 Bit-Datentype für die einzelnen Attribut-Komponenten.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.90\textwidth]{aufbau_der_svo-struktur/figures/interleaved_attributes.png}
  \caption{Attribut-Buffer mit verschachtelten Farb- und Richtungswerten  \label{interleaved_attributes}}
\end{figure}






