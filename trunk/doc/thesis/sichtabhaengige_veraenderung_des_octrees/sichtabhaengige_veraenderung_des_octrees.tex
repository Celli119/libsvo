\chapter{Sichtabhängige Veränderung des Octrees}

\section{Übersicht} 

Der Incore-Buffer wird zunächst mit dem Wurzel-Treelet im ersten Slot initialisiert. Die adaptive Anpassung der Baumestruktur wird in vier Schritten realisiert: Zunächst wird der Octree aus der Sicht der Kamera in den Feedback-Buffer gerendert (\textbf{\textit{Analyse-Pass}}). Nach diesem Schritt enthält dieses Buffer für jeden Strahl u.A. die Position des getroffenen Knoten im Incore-Buffer und einen Fehlerwert. War der getroffene Knoten ein Blatt, zu dessen Verfeinerung ein Treelet vorhanden ist, wird zusätzlich noch dessen Index gespeichert.\\
Nach der Übertragung des Feedback-Buffers in den Hauptspeicher werden dessen Einträge in zwei Kontainer verarbeitet (\textbf{\textit{Vorsortierung}}). Der eine enthält die Treelet-Indices aller Knoten die getroffen wurden und zusätzlich die Treelet-Indices ihrer übergeordneten Treelets bis zum Wurzel-Treelet. Der andere Kontainer enhält Anfragen nach Verfeinerung in Form der Treelet-Indices der anzuhängen Treelets. Die Fehlerinformation bleibt dabei in beiden Kontainern erhalten.\\
Jetzt werden beide Kontainer dem Speichermanagement übergeben(\textit{\textbf{clientseitige\- Aktualisierung}}). Dort werden zunächst die Sichtbarkeitsinformation aller im letzten Zyklus gesehenden Treelets aktuallisiert. Danach werden die neu anzuhängenden Treelets in den clientseitigen Incore-Buffer eingepflegt. Dabei werden nicht sichtbare Treelets entfernt falls im Incore-Buffer keine freien \textit{Slots} mehr zur Verfügung stehen. Geänderte Slots werden markiert. Abschließend werden die veränderten Bereiche des Incore-Buffers an den Server übertragen und stehen nun dem Renderer für den nächsten Zyklus zur Verfügung (\textbf{\textit{serverseitige Aktualisierung}}).\\
Die folgenden Abschnitte werden diese Schritte genauer betrachten.

\section{Der Analyse Pass}
Um die Last die durch diesen zusätzlichen Render-Pass entsteht möglichst gerring zu halten ist die Größe des zur Analyse verwendeten Zielbuffer wesentlich kleiner als die des für die Bildgenerierung verwendete Frame-Buffers. Um Artefaktbildung zu vermindern werden die Strahlen bei jedem Analyseschritt durch Zufallswerte parallel zur Sicht-Ebene verschoben. Die Verschiebung ist dabei so gewählt das über die Zeit im Bereich von $nxn$ Frame-Buffer Texeln abgetasted wird wobei $n$ das Verhältnis der Größen von Frame-Buffer und Analyse-Buffer ist.
Damit ist es möglich den Analyse-Buffer auf bis $1/8$ der Göße des Frame-Buffers zu verkleinert ohne das es durch Aliasing zu Artefaktbildung kommt oder zu wenig Information zur Verfügung steht um die nachfolgende dynamische Anpassung des Octrees zu treiben.\\

Das Füllen des Feedback-Buffers erfolgt analog zum bilderzeugenden Raycasting in OpenCl. Nach der Traversierung des Octrees liegt für jeden Strahl eines der folgenden drei Ergebnisse vor:  
\begin{enumerate}
  \item der Strahl trifft nicht  
  \item der Strahl trifft einen inneren Knoten
  \item der Strahl trifft ein Blatt
\end{enumerate}
Im ersten Fall wird nichts zurückgegeben, im Zweiten nur die Position des Voxels im Incore-Buffer und die Länge des Strahles. Im dritten Fall wird zusätzlich der Verweis auf ein evt. vorhandenes Sub-Treelet und die Differenz zwischen vorgefundener Voxelgröße und der für die Länge des Strahles idealen Voxelgröße als Fehlerwert gespeichert.

\begin{lstlisting}[caption=Struktur eines Feedback-Elementes]{structFeedBackDataElement}
  struct FeedBackDataElement
  {
    int   _nodeId;
    float _error;
    int   _subTreeletGid;
    float _tmin;
  };
\end{lstlisting}


\section{Vorsortierung}
Nach dem Transfer des Analyse-Buffers vom Server in den Hauptspeicher, werden dessen Elemente ausgewertet. Dabei werden zwei Kontainer mit unterschiedlichen Sichtinformationen gefühlt. Im ersten Kontainer werden Indices von Treelets notiert, die bereits im Incore-Buffer vorhanden sind, im Zweiten nur Anfragen nach neuen Treelets. Beide Kontainer sind nach dem Fehlerwert der Einträge absteigend sortiert wobei jeder Treelet-Index über beide Kontainer hinweg unique ist.\\
Im oben beschriebenen Fall 1 (der Strahl trifft nicht) liegen keine Sichtbarkeitsinformation vor weshalb solche Einträge übersprungen werden. Im Fall 2 (der Strahl trifft einen inneren Knoten) wird über die erhaltene Position des Knoten im Incore-Buffer und über die Größe eines Treelets auf den \textit{Slot} des zugehörigen Treelets und damit auch auf den entsprechenden Treelet selbst geschlossen. Durch die in den Treelets gespeicherten Eltern-Information werden zusätzlich alle Übergeordneten Treelets als sichtbar notiert. Tritt bei der Notation ein Treelet mehrfach auf, wird jeweils der größte Fehler notiert.\\
Im Fall 3 (der Strahl trifft ein Blatt) wird für den Blattknotenindex wie im Fall 2 vorgegangen. Zusätzlich wird der Treelet-Index des anzuhängenden Treelets im entsprechenden Kontainer gespeichert. Tritt ein Treelet-Index mehrfach auf wird auch hier nur ein Eintrag mit dem größten Fehler gespeichert.\\
Nachdem alle Elemente des Feedback-Buffers verarbeitet wurden werden beide Kontainer dem Speichermanager übergeben.

\section{Clientseitige Aktualisierung}
Die Pflege der Sichtbarkeitsinformationen der bereits im Incore-Buffer befindlichen Treelets ist trivial: Zunächst wird die Sichtbarkeit jedes \textit{Slots}, d.h. die Sichtbarkeit jedes im \textit{Incore-Buffer} befindlichen Treelets dekrementiert. Dann wird die Sichtbarkeit derjenigen Treelets aktualisiert, die beim letzten Analyse-Pass gesehen wurden. Dabei wird die Sichtbarkeit auf einen vorher festgelegten Maximalwert gesetzt der dem Größenverhältnis von Render-Buffer und Analyse-Buffer entspricht. %Da die Anzahl der berechneten Samples im Analyse-Buffer bei einem Größenverhältnis von $1/8$ nur einem $1/64$ der berechneten Pixel im Framebuffer entspricht währe anzunehemen das die miximale Sichtbarkeitswert höher sein müsste. 

\subsection{Einfügen eines Treelets}
Für das Einfügen eines Treelts aus dem in der Vorsortierung erstellten Kontainers wird zunächst ein freier Slot innerhalb des Incore-Buffers benötigt. Ist dieser vorhanden kann das Treelet an die ensprechende Stelle im Incore-Buffer kopiert werden. Der Slot-Index wird im Treelet-Objekt gespeichert und zur Aktuallisierung des serverseitigen Incore-buffers vorgemerkt. Die folgende Veränderung der Baumstruktur kann in Listing \ref{lst:insert_treelet} nachvollzogen werden. Aus dem Treelet werden folgende Informationen gelesen:
\begin{enumerate}
  \item der Treelet-Index des Eltern-Treelets
  \item der Knoten-Index des Blattes, an dem das Treelet angehängt werden soll
  \item der Eltern-Knoten-Index des Blattes
  \item die Position des Blattes in seinem Eltern-Knoten
\end{enumerate}
Damit wird nun die Position des ensprechneden Blattknotens des Eltern-Treelets im Incore-Buffer ermittelt und durch den Wurzelknoten des anzuhängenden Treelets ersetzt. Dadurch muss dessen relative Index zu seinem ersten Kindknoten angepasst werden. Der erste Kindknoten des neuen inneren Knotens findet sich immer an zweiter Position innerhalb des angehängten Treelets im Incore-Buffer. Der Blattknoten wird damit zu einem inneren Knoten, was wiederum in seinem Elternknoten an der ensprechenden Stelle in der \textit{Childmask} markiert wird. In einem weiteren Kontainer wird vermerkt, dass das Parent-Treelet nun ein neues Kind-Treelet im Incore-Buffer besitzt. Abschließend wird der Slot-Index des Parent-Treelets zur späteren serverseitigen Aktualisierung vorgemerkt. 
\newpage

\lstinputlisting
    [caption={Einfügen eines Treelets}
       \label{lst:insert_treelet},
       captionpos=t,language=C++]
 {sichtabhaengige_veraenderung_des_octrees/insert_treelet.cpp}


\subsection{Entfernen eines Treelets}
Ist für das Einfügen eines Treelets kein Slot mehr verfügbar muss zunächst ein Slot dessen Treelet nicht sichbar war wieder frei gegeben werden. Dazu wird der Baum der Treelets in einem Thread durchsucht und eine Menge von Kandidaten für das Entfernen vorgehalten. Da diese Suche nebenläufig geschiet ist nicht sichergestellt, dass dieser Kaditat zum Zeitpunkt des Entfernens noch valide ist. Deshalb muss vor dem eigentlichen Entfernen der Sichtbarkeitswert des Slots zunächst erneut überprüft werden. Ausserdem ist es möglich, dass zwar das entsprechende Treelet selbst nicht sichtbar war, jedoch im Falle des Entfernens der entsprechende Blatt-Knoten des Eltern-Treelts. Bild (!!!BILD EINFÜGEN) illustriert diesen Fall der ausnahmslos an den Rändern der Geometry auftritt. Im Bild befindet sich ein geladenes Treelet hinter einer konvexen Wölbung der Geometry und kann so nicht vom Analyse-Pass gesehen werden. Wird dieses Treelt jedoch entfernt, ragt der entstehende Blatt-Knoten des Eltern-Treelets über die Wölbung hinaus. Im nächsten Zyklus würde dieses Blatt wieder verfeinert werden wodurch es zu flakernden Artefakten an den Geometriekanten kommt. Um diese Artefaktbildung zu verhindern werden Umgebungsinformationen, sprich die Sichtbarkeit des Eltern-Treelts mitüberprüft. Nur wenn auch das Eltern-Treelet nicht sichtbar ist, kann das Treelet sicher entfernt werden.\\
Alle Slots von im Incore-Buffer gespeicherten Treelts die sich unterhalb des zu entfernenden Treelts befinden können sofort freigegeben werden. Dazu wird die Kind-im-Incore-Buffer-Information des Kandidaten-Treelets und rekursiv die aller untergeordneten Treelets traversiert. So werden im günstigen Fall gleich mehrere Slots freigegeben.\\
Die Manipulation des Incore-Buffers zum Entfernen des Kandidaten-Treelets läuft weitestgehens analog zum Einfügen ab. Die folgenden Schritte können im Listing \ref{lst:remove_treelet} nachvollzogen werden. Wieder wird das Eltern-Treelet, die Position des entsprechenden Blatt-Knoten und dessen Eltern-Knotens ermittelt. Dann wird der Blatt-Knoten durch sein Original aus dem Eltern-Treelet überschrieben. Aus dem inneren Knoten wird so wieder ein Blatt-Knoten mit Verweis auf ein mögliches anhängbares Treelet. Dies wird im Eltern-Knoten des Blatt-Knotens an der entsprechenden Stelle in der \textit{Childmask} markiert. Da sich damit das Eltern-Treelet im Client-seitigen Incore-Buffer geändert hat muss dessen Slot zur serverseitigen Aktuallisierung vorgemerkt werden.
%Ist der Incore-Buffer zu klein um den benötigten Schnitt durch den Baum der Treelets zu halten, stehen keine Kandidaten zum Entfernen zur Verfügung. In diesem Fall wird für jedes Treelet im Incore-Buffer

\lstinputlisting
    [caption={Entfernen eines Treelets}
       \label{lst:remove_treelet},
       captionpos=t,language=C++]
 {sichtabhaengige_veraenderung_des_octrees/remove_treelet.cpp}


\section{Serverseitige Aktualisierung}
Die Slots die beim Einfügen und Entfernen von Treelets markiert wurden werden in diesem Schritt auf den Server übertragen. Dabei kann im einfachsten Fall jeder Slot innerhalb des Incore-Buffers einzeln übertragen werden. Dies führt jedoch zu vielen Einzelübertragungen von geringer Größe. Dies ist sehr ungünstig da für jede Kopieroperation ein nicht unerheblicher Verwaltungsaufwand innerhalb der OpenCL-API anfällt (!!! NACHWEIS). Handelt es sich beim verwendeten Server um eine GPU müssen die Daten zusätzlich über den PCI-Express-Bus übertragen werden. Auch hier kann die maximale Übertragungsrate nur duch möglichst große Pakete erreicht werden (!!! NACHWEIS).\\
Um die Anzahl der Kopieraufrufe möglichst gering zu halten werden deshalb nahe aneinanderliegende Slots zusammengefasst und gemeinsam kopiert. Dazu werden die Indices der zu aktualisierenden Slots sortiert vorgehalten. Ausgehend vom ersten Slot-Index wird der zu kopierende Speicherbereich so lange bis zum nächsten Slot erweitern bis das Verhältnis zwischen zu aktualisierenden Slots und unveränderten Slots innerhalb dieses Bereiches unter ein festgelegtes Niveau sinkt.\\
Am effizientesten arbeitet dieser Ansatz wenn der Incore-Buffer anfangs noch leer ist da die Slots-Indices aufeinanderfolgend herausgegeben werden und damit an einem Stück auf den Server transferiert werden.
%Mit steigender Fragmentierung des Incore-Buffers sinkt die Einsparung jedoch und schwankt stark. Bei einem vorgegebenen Verhältis zu aktualisierenden Slots von 20\% etwa schwankt die Einsparung zwischen 10\% bis 92\% und lag über einen Zeitraum von 60 Sekunden im Mittel bei etwa 43\%. Die hier examplarisch genannten Werte sind jedoch wenig aussagekräftig, da das Verhalten des Ansatzes nicht nur von der Anzahl der Slots, der Größe und dem Fragmentierungsgrad des Incore-Buffers abhängt, sondern auch von der Geometrie und der Kameraposition über die Zeit. Eine Verbesserung zum einzelnen Kopieren der Slots ist jedoch erkennbar.
Das Zusammenfassen der Slots kann ausserdem in einem Thread ausgelagert werden damit sich der entstehende Zeitaufwand nicht auf die Bildrate auswirkt. \\

\section{Laufzeitbetrachtung}
