\chapter{Einleitung}
\section{Motivation}
Seit ihrer Vorstellung in den späten 70er Jahren (!!! REFERENCE) ist die Bildsynthese durch Rasterisierung von parametrisierten Dreiecken der Quasi-Standard für Echtzeitcomputergrafik. Diese Entwicklung wurde nicht zuletzt durch die Einführung von dezidierter Hardware und offenen Standards, wie OpenGL möglich. Der Vorteil von Dreiecken als Geometrieprimitiv ist, dass sich mit ihnen sehr effizient planare Flächen darstellen lassen. Dabei hat die Größe der abgebildeten Flächen keinen Einfluss auf den Speicherbedarf der Repräsentation. In modernen Anwendungen, wie Spielen oder bei der Darstellung von hochauflösenden 3d-Scanns ist dieser Vorteil jedoch immer weniger relevant, da der überwiegende Teil des benötigten Speichers durch Texturen belegt wird. Diese werden benötigt, um die Flächen mit Details zu versehen, wie Farbe, Richtung und andere zur Beleuchtung benötigten Attribute. Dabei ist die Parametrisierung mit Textur\-koordinaten von komplex geformten Dreiecksnetzen nicht trivial und muss deshalb meist händisch bewerkstelligt werden.\\
Bei der Rasterisierung von detaillierten Dreiecksnetzen mit hochaufgelösten Texturen kommt es schnell zu Aliasing\-artefakten. Um diese zu reduzieren, werden von Dreiecksnetz und Texturen niedriger aufgelöste, statische Versionen erzeugt (\textit{Level-of-Detail, LOD}). Zwischen diesen wird bei der Darstellung je nach Betrachtungsabstand gewechselt, was zu störenden \textit{Popping}-Artifakten führt. Dabei kann nur im seltensten Fall ein ideales Verhältnis zwischen Geometrie- und gegebener Bildauflösung gewährleistet werden. Das dynamische Erstellen von LOD-Stufen aus einem hochauflösenden Dreiecksnetz ist nur mit hohen Rechen- oder Speicheraufwand dynamisch zu bewerkstelligen. Außerdem muss das LOD-Problem für Geometrie und Texturdaten während der Erstellung und der Darstellung separat gelöst werden. Ein Nachteil des Rasterisierungsansatzes ist das Fehlen von globalen Informationen während der Fragmentgenerierung. Jedes Primitiv wird für sich behandelt ohne das globale Informationen zur Optimierung (\textit{Culling}) oder Beleuchtung (\textit{Global Illumination}) zur Verfügung stehen.\\ \\
Die Generalisierung der Renderpipelines und die Einführung von GPGPU-Hochsprachen wie OpenCL machen es möglich die Frage nach geeignetem Geometrieprimitiv und Bildsyntheseverfahren neu zu stellen. Sparse Voxel Octree als Datenstruktur in Kombination mit \textit{Raycasting} als Algorithmus zur Bildsynthese bieten viele positive Eigenschaften. So vereinen Sparse Voxel Octrees Geometrie und Texturdaten in einer einzigen hierarchischen Datenstruktur. Durch Raycasting auf dieser Struktur kann das LOD-Problem von Geometrie und Textur gemeinsam pro Bildpunkt gelöst werden. Gleichzeitig wirkt der Octree als Beschleunigungsstruktur, so dass während des Traversierens nur die Teile der Struktur durchlaufen werden, die zur Bildsynthese beitragen. Eine Parametrisierung ist nicht notwendig, da jedes Voxel seine eigenen Attributinformationen spei\-chert, die für seine Größe in optimaler Auflösung vorliegen.\\\\
Denoch gibt es einige Herausforderungen die bei der verwendung von Sparse Voxe Octrees gelöst werden müssen. Sparse Voxe Octrees benötigen viel Speicher. Die Menge an Arbeitsspeicher aktueller Grafikkarten genügt  um eine SVO-Struktur in hinreichender Auflösung zu speichern. Will man möglichst viele Details oder sehr große Strukturen abbilden können leicht mehrere Gigabyte Daten anfallen.\\
Da Sparse Voxel Octrees erst in jüngster Zeit in den Fokus von Wissenschaft und Industrie gerückt sind, sind sie in Programmen zur Erstellung von 3D-Inhalten noch nicht angekommen. Daher lohnt es über die Generierung von Sparse-Voxel-Octrees-Strukturen aus anderen 3D-Datenformaten nachzudenken. 

...
\textbf{Probleme:} Trotz Sparse enorme Datenmenge
\textbf{Probleme:} keine Tools bzw. generalisierte Pipeline zur Erstellung von SVO-Content vorhanden\\


\section{Zielstellung}
In der vorliegenden Arbeit 



\textbf{Zeilstellung 2:} Entwicklung eines Out-Of-Core Ansatzes basierend auf Segmentierung der SVO Daten und adaptives refinement

\textbf{Zeilstellung 1:} Entwicklung eines Templates zur Generierung von SVO aus unterschiedlichen Datenvorlagen (Dreiecke, Pointclouds, Heightmaps, volumen).\\
\\
  
  