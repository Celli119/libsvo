\chapter{Systemkonzeption}



%/////////////////////////////////////////////////////////



\section{Überblick}

 - Fehler bei der Darstellung -> Fehlerwert ausnutzen\\
 - Visueller/Progressiver Ansatz (outputsensitiv)\\
 - Problem bei Visuellen Ansatz: Mann muss das was man sieht einordnen können


\section{Out-of-Core Management}



%/////////////////////////////////////////////////////////



\subsection{Aufbau}


\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.85\textwidth]{figures/out-of-core_setup.pdf}
  \caption{Schematischer Aufbau des Out-Of-Core-Systems\label{out-of-core_setup1}}
\end{figure}



%/////////////////////////////////////////////////////////

\section{Datenstrukturen}


\subsection{Definition der Knotenstruktur}

Die Octree-Struktur in dieser Arbeit ist so aufgebaut, dass jeder Knoten im Baum einen Voxel repräsentiert. Jedes Voxel steht für einen achsen\-parallelen Würfel, der die Oberfläche der abzubildenden Geometrie schneidet. Jedes Voxel kann in bis zu acht weitere Voxel unterteilt werden. Die Indizierung der Kind-Voxel ergibt sich aus ihrer Position innerhalb des Eltern-Voxels. Diese kann durch die Vorschrift \textbf{$i(x,y,z)=4p(x)+2p(y)+p(z)$} bestimmt werden, wobei $p(x)$, $p(y)$ und $p(z)$ für die Ergebnisse der Aussagen $x>0$, $y>0$ und $z>0$ stehen. Abbildung \ref{voxel_idx} zeigt ein vollständig unterteiltes Voxel und die Indizierung seiner Kind-Voxel.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.35\textwidth]{figures/voxel_idx.pdf}
  \caption{Indizierung der Kind-Voxel\label{voxel_idx}}
\end{figure}\\
Die Topologie des Octrees wird durch 64 Bit große Knoten beschrieben. Der Speicherbedarf teilt sich in 32 Bit für den Verweis auf das erste Kind (\textbf{\textit{First-Child-Index}}) und zwei Bitmasken, die jeweils 8 Bit beanspruchen. Eine Bitmaske kodiert in jedem Bit das jeweilige Vorhandensein eines Kindes (\textbf{\textit{Valid-Mask}}). Die zweite Bitmaske kodiert in jedem Bit ob das jeweilige Kind ein Blatt ist oder nicht (\textbf{\textit{Leaf-Mask}}). Abbildung \ref{node_struktur} veranschaulicht den Aufbau der Baumstruktur durch diese Knoten\-repräsentation.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.5\textwidth]{figures/node_memory.pdf}
  \caption{Aufbau eines Knotens\label{node_memory}}
\end{figure} 
16 Bit pro Knoten bleiben für die Anwendung in dieser Arbeit frei. Der freie Platz ist mit den Anforderungen an minimale Speichergrößen und Segmentierung der OpenCL zu erklären, die keine 24 oder 48 Bit Datentypen definiert. Es ist jedoch möglich, diesen Platz zum Speichern von Attributen oder Verweisen zu Kontur\-informationen zu nutzen, wie es in (ESVOR) getan wird. Lösungsvorschläge für eine kompaktere Notation werden in diskutiert.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.55\textwidth]{figures/node_struktur.pdf}
  \caption{Beschreibung der SVO-Struktur\label{node_struktur}}
\end{figure}

%/////////////////////////////////////////////////////////

\newpage

\subsection{Segmentierung}\label{sec:segmentierung}
Bei der Wahl der Speichergröße der Segmente gilt es zwischen Granularität und Aufwand abzuwägen. Um eine hohe Granularität und damit eine hohe Anpassungsfähigkeit der gewählten Untermenge an Segmenten zu gewährleisten, sollte die Größe der Segmente eher klein gewählt werden. Sind die Segmente jedoch zu klein können für einen gegebenen Octree schnell mehrere Millionen davon entstehen, was den Verwaltungsaufwand erhöht. Zu große Segmente können dazu führen das einzelne Operationen auf Segmenten zu viel Zeit benötigen und damit das Gesamtsystem ausbremsen.\\
Die Unterteilung der SVO-Struktur in dieser Arbeit erfolgt in Unterbäumen die als \textit{Treelets} (Bäumchen) bezeichnet werden sollen. Jedes Treelet umfasst die gleiche Anzahl an Knoten und stellt für sich gesehen einen Sparse Voxel Octree mit Wurzel- und Blatt\-knoten dar (vgl. Abbildung \ref{treelet_struktur}). Bei initialen Test haben sich Treelet-Größen zwischen einem und zwölf Kilobyte als günstig erwiesen. Im Abschnitt \ref{sec:test_einfluss_groesse} (\nameref{sec:test_einfluss_groesse}) wird der Einfluß dieser Größe untersucht. Zum Identifizieren eines Treelets erhält jedes einen eindeutigen Index (\textit{Treelet-Index}). Über diesen wird die Verknüpfung der Treelets untereinander realisiert. Dazu speichert jedes Treelet unter anderem den Index des übergeordneten Treelets und die Position des ihm entsprechenden Blattknotens.
Die im Baum abwärts gerichtete Verknüpfung wird durch Speichern der Indices der untergeordneten Treelets im First-Child-Index des je\-wei\-ligen Blattknotes realisiert.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/treelet_struktur.pdf}
  \caption{Treelet-Struktur mit 6 Knoten pro Treelet \label{treelet_struktur}}
\end{figure}
\newpage
Die Verbindung der Treelets untereinander bildet einen bidirektionalen Baum über dem eigentlichen Octree. Abbildung \ref{verbinung_ueber_treelet_index} stellt diese Verbindung dar. Unter der Abbildung des Baumes sind die Werte der First-Child-Pointer für alle Knoten notiert. Durch die abwärts gerichtete Verbindung, die in den Blatt-Knoten gespeichert ist, kann beim Traversieren der Struktur in jedem Blatt das zugehörige Treelet ermittelt werden. Die aufwärts gerichtete Verbindung ermöglicht den effizienten Zugriff auf alle übergeordneten Treelets bis zum Wurzel-Treelet. Dies sind die Treelets, von denen ein gegebenes Treelet für seine Verarbeitung in der SVO-Struktur abhängig ist.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.90\textwidth]{figures/verbinung_ueber_treelet_index.pdf}
  \caption{Verbindung der Treeelets durch ihren Index \label{verbinung_ueber_treelet_index}}
\end{figure}
\newline 


%/////////////////////////////////////////////////////////


\newpage
\subsection{Attribute}\label{sec:attribute}

Attributinformationen werden parallel zu den Treelets in einem oder mehreren Attribut-Buffern gehalten. Diese Buffer können, wie auch die Knotenstruktur des Octrees, sehr groß werden da benötigte Attributwerte für jedes Voxel des Octrees einzeln gespeichert werden. Darum werden die Werte, wie Beleuchtungsinformationen, Farben, Richtungsinformationen oder ambiente Verdeckungswerte (Ambient Occlusion) vor dem Ablegen komprimiert. Dies kann durch die Verwendung von 8 Bit-Datentypen für die einzelnen Attribut-Komponenten geschehen.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/interleaved_attributes.png}
  \caption{Attribut-Buffer mit verschachtelten Farb- und Richtungswerten  \label{interleaved_attributes}}
\end{figure}



%/////////////////////////////////////////////////////////


\newpage
\section{Generalisiertes System zur Erstellung von Sparse Voxel Octrees}
Das System zur Erstellung der SVO-Struktur ist modular aufgebaut und besteht prinzipiell aus drei Teilen: Dem \textbf{\textit{Build-Manager}} der den Ablauf der SVO-Generierung steuert, einem \textbf{\textit{Treelet-Builder}} der die Treelets erstellt und abhängig vom Typ der Eingabedaten gewählt wird und einem \textbf{\textit{Attributgenerator}} der in Abhängig von Eingabedaten und gewünschter Attributkonfiguration der Ausgabedaten gewählt werden kann. Mit dieser Unterteilung des Systems ist es prinzipiell möglich, unterschiedliche Eingabedaten wie 3D-Objekte aus Dreiecksnetzen oder Punktwolken zu verarbeiten und eine Vielzahl von Attribut\-konfigurationen zu erstellen. Durch den modularen Aufbau und die Bereitstellung entsprechender Basisklassen ist es möglich, Unterstützung für weitere Eingabeformate zu schaffen.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/uml.pdf}
  \caption{Klassendiagram des generallisierten Erstellungssystems \label{uml_diagam}}
\end{figure}
Das in Abbildung \ref{uml_diagam} gezeigte Klassen\-diagramm stellt die Relationen zwischen den einzelnen Komponenten dar. Der Build-Manager besitzt einen Treelet-Builder der abhängig von der Art der Eingabedaten gewählt wird. Dazu besitzt er einen passenden Attributgenerator der anhand der Eingabedaten und SVO-Repräsentation Attribute für alle Knoten erzeugt.

%/////////////////////////////////////////////////////////

\section{Verwendete Infrastruktur}
gloost
opencl
bencl
%/////////////////////////////////////////////////////////

\section{Client-Server-Architektur}
Es kommt darauf an wer die Anfragen stellt, nicht wer die Daten hält.


%/////////////////////////////////////////////////////////




\section{Real Time Rendering von Sparse Voxel Octrees}

