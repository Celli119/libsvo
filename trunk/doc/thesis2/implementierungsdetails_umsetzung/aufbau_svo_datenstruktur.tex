
\section{Aufbau der Sparse Voxel Octree Datenstruktur}





%/////////////////////////////////////////////////////////




%/////////////////////////////////////////////////////////



\subsection{Erzeugung der Treelet Struktur}\label{sec:erzeugung_treelet_struktur}

Die SVO-Struktur wird schon bei der Erstellung segmentiert, das heißt, in Treelets unterteilt. Sollte der Ar\-beits\-speicher für die erzeugten Daten nicht ausreichen, bestht daher die Möglichkeit, bereits erzeugte Treelets auf die Festplatte auszulagern. Im Folgendem soll ein Überblick über den Ablauf der Erstellung einer SVO-Struktur aus Treelets gegeben werden. In den folgenden Abschnitten werden die einzelnen Schritte genauer betrachtet.\\\\
Als Eingabe werden zunächst die geforderte minimale Tiefe des resultierenden Octrees, die Speichergröße der Treelets und der Pfad zu den Eingabedaten benötigt. Der Build-Manager erstellt ein initiales, leeres Treelet (\textit{Wurzel-Treelet}) und übergibt dieses an den Treelet-Builder. Dieser füllt das Treelet anhand der Eingabedaten. Anschließend werden alle entstandenen Blatt-Knoten, die noch nicht die geforderte, minimale Tiefe in der Octree-Struktur aufweisen, notiert. Zu jedem dieser Blattknoten wird eine Liste der in ihm liegenden Primitive der Eingabedaten gespeichert. Zusätzlich wird auch die Tiefe des Knotens im Baum und seine Transformation relativ zum Wurzelknoten notiert. Um die Verknüpfung der Treelets untereinander realisieren zu können wird außerdem der Treelet-Index, der Index des Blattknotens und dessen Elternknotens gespeichert (vgl. Abschnitt \ref{sec:segmentierung} \nameref{sec:segmentierung}, Seite \pageref{sec:segmentierung}). Der Build-Manager speichert diese Informationen in einer Queue und erzeugt für jeden Eintrag ein neues Treelet (\textit{Top-Down}). Diese neuen Treelets werden durch die gespeicherten Treelet- und Blattknotenindices des Wurzel-Treelets initialisiert und sind so logisch mit diesem verbunden. Jedes dieser Treelets wird wiederum dem Treelet-Builder übergeben, der es anhand seiner Primitivliste und der gespeicherten Transformation mit Voxeln füllt. Der Build-Manager erzeugt sukzessiv weitere Treelets aus Blattknoten bereits erstellter Treelets bis die geforderte minimale Tiefe des Octrees für alle Blattknoten erreicht ist.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.83\textwidth]{figures/treelet_building.pdf}
  \caption{Schrittweiser Aufbau der SVO-Struktur aus Treelets \label{fig:treelet_building}}
\end{figure}
\newpage
Für Blattknoten mit ausreichender Tiefe erzeugt ein Attributgenerator die gewünschten Attribute und speichert diese in einem zusätzlichen Buffer. Die Primitiv\-liste sowie alle weiteren Informationen, die zur Erstellung weiterer Treelets benötigt würden, können an dieser Stelle verworfen werden. Abbildung \ref{fig:treelet_building} zeigt den schrittweisen Aufbau eines Octrees aus Treelets.\\
Ist die Erstellung der Treelets abgeschlossen, werden die Attribute der inneren Knoten durch Mitteln der Attribute ihrer Untergeordneten Knoten erstellt. Dies geschieht für alle Treelets in umgekehrter Reihenfolge ihrer Erstellung (\textit{Bottom-Up}). So wird sichergestellt, dass der Wurzelknoten eines untergeordneten Treelets bereits Attributinformation enthält, wenn sein übergeordnetes Treelet diese zur Generierung der Attribute in seinen Blattknoten benötigt. Mit der Erstellung der Attribute in dem Wurzelknoten des Wurzel-Treelets ist die Erstellung des Octrees abgeschlossen. 




%/////////////////////////////////////////////////////////



\subsection{Treelet Aufbau}
Der Treelet-Builder erstellt die Knoten in der Breite (\textit{Breadth-First}) und arbeitet dazu intern auf einem FIFO-Container (\textit{Queue}). Der Aufbau eines Elementes dieser Queue ist im Listing \ref{lst:queueelement} zu sehen. Jedes Element der Queue entspricht einem Knoten in der SVO-Struktur und enthält alle nötigen Informationen, um diesen Knoten seinem übergeordneten Knoten mitzuteilen sowie die Erzeugung weiterer Unterknoten zu ermöglichen.

%\begin{figure}[position=h width=0.75\textwidth]
%  \centering
\begin{lstlisting}[caption={Queue-Element},label={lst:queueelement}]
struct QueueElement
{
  // Knoten-Index des Knotens innerhalb des Treelets
  unsigned              _localLeafIndex;         
  // Kind-Index des Knotens innerhalb seines Eltern-Knotens
  char                  _idx;                    
  // Knoten-Index des Eltern-Knotens
  unsigned              _parentLocalNodeIndex;   
  // Tiefe des Knotens in der SVO-Struktur
  unsigned              _depth;                  
  // Transformation des Knotens relativ zum Wurzelknoten
  gloost::Matrix        _aabbTransform;          
  // In diesem Knoten enthaltene Primitive der Ausgangsdaten
  std::vector<unsigned> _primitiveIds;           
};
\end{lstlisting}
%\end{figure}
Initial wird ein Queue-Element stellvertretend für den Wurzelknoten des aktuellen Treelets erstellt. Dieses enhält die relative Transformation des Knotens in der SVO-Struktur sowie alle Primitive, die in diesem Knoten liegen. Für jeden potentiellen Kind-Knoten wird ein Queue-Element mit entsprechenden Parametern erzeugt und dessen \textit{Bounding Box} mit  Primitiven des aktuellen Queue-Elementes zum Schnitt gebracht. Dabei wird für jeden Kindknoten die Untermenge an Primitiven notiert, die geschnitten wurden. Falls ein Kindknoten keine Primitive enthält, wird es verworfen. Kindknoten, die Primitive enthalten, erhalten aufeinanderfolgende Speicherpositionen innerhalb des Treelets.\\
Die Position des ersten Kindknotens wird im \textit{First-Child-Index} des Knotens des aktuellen Queue-Elements gespeichert. Nun werden die Queue-Elemente der Kindknoten zur weiteren Verfeinerung in die Queue eingereiht. Vor dem Abarbeiten eines Queue-Elementes wird überprüft, ob im Treelet noch genügend freie Plätze für eine weitere Unterteilung vorhanden sind. Sind weniger als acht Plätze übrig, muss nach der nächsten Unterteilung erst überprüft werden, ob die entstanden Kindknoten noch in das Treelet passen, bevor die Unterteilung gespeichert werden kann. Ist dies nicht der Fall, wird versucht ein Queue-Element zu finden, dessen Bearbeitung weniger neue Knoten erzeugt. Kann kein solches Queue-Element gefunden werden, ist die Erstellung des Treelets abgeschlossen.\\
Die in der Queue verbliebenen Elemente werden nach ihrer Baumtiefe in finale und weiter zu unterteilende Elemente getrennt und in zwei Containern im Treelet gespeichert. Nachdem die finalen Knoten in den Leaf-Masks der Eltern-Knoten als solche markiert wurden, wird das Treelet an den Build-Manager zurückgegeben.\\\\
Der Build-Manager erzeugt für jedes nicht finale Queue-Element ein weiteres Treelet. Der Indices der neu erstellten Treelets werden im \textit{First-Child-Index} der zugehörigen Blattknoten des übergeordneten Treelets gespeichert. Jedes dieser Treelets wird mit einer Primitivliste, seiner Transformation und dem Eltern-Treelet-Index parametrisiert in der Queue des Build-Managers einge\-reiht um sie in entsprechender Reihenfolge an den Treelet-Builder weitergeben zu können. Der oben beschriebene Ablauf wiederholt sich daraufhin für jedes Treelet in der Queue. Liefert der Treelet-Builder nur noch Treelets mit finalen Blattknoten, leert sich die Queue und das Erstellen der SVO-Struktur ist abgeschlossen. 


%/////////////////////////////////////////////////////////


\subsection{Attribut-Generierung}
Zu jedem Treelet werden parallel ein oder mehrere Buffer mit verschachtelten (\textit{interleaved}) Attributwerten erstellt. Die Verschachtelung sorgt für einen speicherkohärenten Zugriff auf alle Attributwerte eines Voxels. Anzahl und Layout der Attribut-Buffer sind abhängig vom gewählten Attribut-Generator.\\
Für jeden finalen Blattknoten wird mit Hilfe der gespeicherten Primitive und Transformation eine Menge von Attributen erzeugt. Dieser Vorgang soll im Folgenden am Beispiel von Dreiecks\-primitiven erläutert werden. Für jedes Dreieck innerhalb eines Blatt-Knotens wird ein Strahl erzeugt, der durch die Voxel\-mitte und senkrecht zum Dreieck verläuft (vgl. Abbildung \ref{voxel_primitiv_schnitt}a). Es werden die Schnittpunkte des Strahls mit dem Dreieck ermittelt, um damit UV-Koordinaten berechnen zu können.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.85\textwidth]{figures/voxel_primitiv_schnitt.pdf}
  \caption{Ermittlung von UV-Koordinaten\label{voxel_primitiv_schnitt}}
\end{figure}
Durch die senkrechte Ausrichtung des Strahls zur Dreicks\-fläche wird die Wahrscheinlichkeit eines Schnittes erhöht. Trotzdem ist es möglich, dass der Strahl das Dreieck verfehlt, da das Voxel das Dreieck bei\-spiels\-weise nur mit einer Ecke schneidet, die nicht zur Voxel-Mitte ausgerichtet ist (vgl. Abbildung \ref{voxel_primitiv_schnitt}b). Um trotzdem den Beitrag des Dreiecks zu den Voxel-Attributen berücksichtigen zu können,  wird in diesem Fall der Punkt auf dem Dreieck als Schnittpunkt angenommen, der den kleinsten Abstand zum Schnittpunkt mit der Dreiecksebene besitzt. Dieser Vorgang erzeugt ein Rauschen in den Daten, das aber angesichts der geringen Größe der Blatt-Knoten und des daraus resultierenden geringen Fehlers keinen nennenswerten Einfluss auf die subjektive Bildqualität hat. Mit Hilfe der ermittelten UV-Koordinaten können nun Attribute wie Farbe oder Richtung aus den Eckpunkten der Dreiecke interpoliert oder aus Texturen gelesen werden. Aus den Werten aller am Voxel beteiligten Dreiecke wird ein Mittelwert gebildet. Farb- und Richtungs\-werte werden auf 8 Bit pro Komponente quantisiert bevor sie in den Attributbuffer gespeichert werden.\\
\newpage
Wie in Abschnitt \ref{sec:erzeugung_treelet_struktur} beschrieben, werden die Attribute der inneren Knoten erst erzeugt, nachdem die Erstellung aller Treelets ab\-ge\-schlos\-sen ist. Durch die Verwendung eines FIFO-Containers im Build-Manager sind die Treelets so nummeriert, dass jedes Treelet einen niedrigeren Index besitzt als seine untergeordneten Treelets. Das Treelet mit dem höchsten Index besitzt schon in allen seinen Blatt-Knoten Attribute und ist somit von keinem anderen Treelet für die Generierung seiner Attribute abhängig. Das Treelet mit dem Index $0$ ist dagegen für seine Attributgenerierung von allen anderen Treelets abhängig. Für die Generierung der Attribute werden die Treelets daher in umgekehrter Reihenfolge ihrer Indizierung verarbeitet. Abbildung \ref{attribute_generation} veranschaulicht die Reihenfolge anhand eines Beispiels (vgl. Abbildung \ref{fig:treelet_building}).
\begin{figure}[position=v]
  \centering
  \includegraphics[width=0.70\textwidth]{figures/attribute_generation.pdf}
  \caption{Reihenfolge der Erzeugung der Attributen innerer Knoten\label{attribute_generation}}
\end{figure}\\
Beginnend beim Treelet mit dem größten Index wird jedes Treelet vom Wurzelknoten an der Tiefe nach rekursiv durchlaufen bis die Blattknoten erreicht werden. Beim Aufsteigen aus der Rekursion wird aus den Attributen der  vorhandenen Kindknoten ein Mittelwert gebildet und im Attribut-Buffer abgelegt. Dazu werden die mit 8 Bit aufgelösten Attribut\-komponenten der Kindknoten zunächst wieder in 32 Bit Fließ\-komma\-werte konvertiert, um die Quantisierungsfehler bei der Ermittlung des Mittelwerts nicht unnöig zu verstärken. Nachdem auch für den Wurzelknoten ein Attribut vorhanden ist, wird dieses in den Attribut-Buffer des übergeordneten Treelets für den entsprechenden Blattknoten abgelegt. Durch die Reihenfolge der Indizierung ist für jedes Treelet sichergestellt, dass für alle Blatt\-knoten Attributinformationen vorhanden sind wenn sie zur Generierung der Attribute der inneren Knoten benötigt werden.



