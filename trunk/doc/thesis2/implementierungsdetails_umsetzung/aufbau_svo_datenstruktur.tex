
\section{Aufbau der SVO Datenstruktur}


\subsection{Definition der Knotenstruktur}

Die Octree-Struktur in dieser Arbeit ist so aufgebaut, das jeder Knoten im Baum einen Voxel repräsentiert. Jeder Voxel steht für einen achsen\-paralleler Würfel der die Oberfläche der abzubildenden Geometrie schneidet. Jeder Voxel kann in bis zu acht weitere Voxel unterteilt werden. Die Indizierung der Kind-Voxel ergibt sich aus ihrer Position innerhalb des Eltern-Voxels. Diese kann durch die Vorschrift \textbf{$i(x,y,z)=4p(x)+2p(y)+p(z)$} bestimmt werden, wobei $p(x)$, $p(y)$ und $p(z)$ für die Ergebnisse der Aussagen $x>0$, $y>0$ und $z>0$ stehen. Abbildung \ref{voxel_idx} zeigt ein vollständig unterteilten Voxel und die Indizierung seiner Kind-Voxel.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.35\textwidth]{figures/voxel_idx.pdf}
  \caption{Indizierung der Kind-Voxel\label{voxel_idx}}
\end{figure}\\
Die Topologie des Octrees wird durch 64 Bit große Knoten beschrieben. Der Speicherbedarf teilt sich in 32 Bit für den Verweis auf das erste Kind (\textbf{\textit{First-Child-Index}}) und zwei Bitmasken, die jeweils 8 Bit beanspruchen. Eine Bitmaske kodiert in jedem Bit das jeweilige Vorhandensein eines Kindes (\textbf{\textit{Valid-Mask}}). Die zweite Bitmaske kodiert in jedem Bit ob das jeweilige Kind ein Blatt ist oder nicht (\textbf{\textit{Leaf-Mask}}). Abbildung \ref{node_struktur} veranschaulicht den Aufbau der Baumstruktur durch diese Knoten\-repräsentation. 
16 Bit pro Knoten bleiben für die Anwendung in dieser Arbeit frei, können aber auf verschiedene Weise genutzt werden. Beispielsweise ist es möglich diesen Platz zum Speichern von Attributen oder Verweisen zu Kontur\-informationen zu nutzen, wie es in (ESVOR) getan wird. Der freie Platz ist mit den Anforderungen an minimale Speichergrößen und Segmentierung der OpenCL zu erklären, die keine 24 oder 48 Bit Datentypen definiert. Lösungsvorschläge für eine kompaktere Notation werden in ( !!! verweis auf verbesserungen) diskutiert.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.55\textwidth]{figures/node_memory.pdf}
  \caption{Aufbau eines Knotens\label{node_memory}}
\end{figure}
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.55\textwidth]{figures/node_struktur.pdf}
  \caption{Beschreibung der SVO-Struktur\label{node_struktur}}
\end{figure}



%/////////////////////////////////////////////////////////



\subsection{Segmentierung}\label{sec:segmentierung}

\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/treelet_struktur.pdf}
  \caption{Treelet-Struktur mit 6 Knoten pro Treelet \label{treelet_struktur}}
\end{figure}
Die Unterteilung der SVO-Struktur erfolgt in Unterbäumen die in dieser Arbeit als \textit{Treelets} (Bäumchen) bezeichnet werden. Jedes Treelet umfasst die selbe Anzahl an Knoten und stellt für sich gesehen einen Sparse Voxel Octree, mit Wurzel- und Blatt\-knoten dar (vgl. Abbildung \ref{treelet_struktur}). Zum Identifizieren eines Treelets erhält jedes einen eindeutigen Index (\textit{Treelet-Index}). Über diesen wird die Verknüpfung der Treelets untereinander realisiert. Dazu speichert jedes Treelet den Index seines übergeordnet Treelets und die Position des jeweiligen Blattknotens.
Die im Baum abwärts gerichtete Verknüpfung wird durch Speichern der Indices der untergeordneten Treelets im First-Child-Index des je\-wei\-ligen Blattknotes realisiert.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.90\textwidth]{figures/verbinung_ueber_treelet_index.pdf}
  \caption{Verbindung der Treeelets durch ihren Index \label{verbinung_ueber_treelet_index}}
\end{figure}
Die Verbindung der Treelets untereinander bildet einen bidirektionalen Baum über dem eigentlichen Octree. Abbildung \ref{verbinung_ueber_treelet_index} stellt diese Verbindung dar. Unter der Abbildung des Baumes sind Werte der First-Child-Pointer für alle Knoten notiert.\\
Durch die abwärts gerichtete Verbindung, die in den Blatt-Knoten gespeichert ist kann beim Traversieren der Struktur in jedem Blatt das zugehörige Treelet ermittelt werden um dieses bei Bedarf anzufordern. Die aufwärts gerichtete Verbindung ermöglicht den effizienten Zugriff auf alle übergeordneten Treelets bis zum Wurzel-Treelet von denen ein gegebenes Treelet für seine Verarbeitung in der SVO-Struktur abhängig ist.
\newline
Die Speichergröße der Treelets kann bei der Erstellung des Baumes angegeben werden. Für die Tests in dieser Arbeit wurden Größen zwischen einem und zehn Kilobyte gewählt. Dabei gilt es bei der Wahl der Speichergröße zwischen Granularität und Aufwand abzuwägen  Um eine hohe Granularität und damit eine hohe Anpassung der gewählten Untermenge an Segmenten zu gewährleisten, sollte die Größe der Treelets eher klein gewählt werden. Sind die Treelets jedoch zu klein können für einen gegebenen Octree schnell mehrere Millionen Treelets entstehen. Deshalb ist es nötig für jeden als Treelet-Struktur abzubildende Datensatz eine geeignete Treelet-Größe zu wählen.



%/////////////////////////////////////////////////////////



\section{Attribute}\label{sec:attribute}

Attributinformationen werden parallel zu den Treelets in einem oder mehreren Attribut-Buffern gehalten. Diese Buffer können, wie auch die Knotenstruktur des Octree, sehr groß werden da benötigte Attributwerte für jeden Voxel des Octrees einzeln gespeichert werden. Darum werden die Werte, z.B. Beleuchtungsinformationen wie Farben, Richtungsinformationen oder ambiente Verdeckungswerte (Ambient Occlusion) vor dem Ablegen komprimiert. Dies kann durch die Verwendung von 8 Bit-Datentypen für die einzelnen Attribut-Komponenten.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.90\textwidth]{figures/interleaved_attributes.png}
  \caption{Attribut-Buffer mit verschachtelten Farb- und Richtungswerten  \label{interleaved_attributes}}
\end{figure}



%/////////////////////////////////////////////////////////



\subsection{Generalisiertes System zur SVO-Erstellung}
Das System zur Erstellung der SVO-Struktur ist modular aufgebaut und besteht prinzipiell aus drei Teilen: Dem \textbf{\textit{Build-Manager}} der den Ablauf der SVO-Generierung steuert, einem \textbf{\textit{Treelet-Builder}} der die Treelets erstellt und abhängig vom Typ der Eingabedaten gewählt wird und einem \textbf{\textit{Attributgenerator}} der in Abhängig von Eingabedaten und gewünschter Attributkonfiguration der Ausgabedaten gewählt werden kann. Mit dieser Unterteilung des Systems ist es prinzipiell möglich verschiedenste Eingabedaten wie 3D-Objekte aus Dreiecksnetzen oder Punktwolken zu verarbeiten und eine Vielzahl von Attribut\-konfigurationen zu erstellen. Durch den modularen Aufbau und der Bereitstellung entsprechender Basisklassen ist es möglich Unterstützung für weitere Eingabeformate zu schaffen.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/uml.pdf}
  \caption{Klassendiagram des generallisierten Erstellungssystems \label{uml_diagam}}
\end{figure}
Das in Abbildung \ref{uml_diagam} abgebildete Klassen\-diagramm zeigt die Relationen zwischen den einzelnen Komponenten. Der Build-Manager besitzt einen Treelet-Builder der abhängig von der Art der Eingabedaten gewählt wird. Dazu besitzt er einen passenden Attributgenerator der anhand der Eingabedaten und SVO-Repräsentation Attribute für alle Knoten erzeugt.




%/////////////////////////////////////////////////////////



\subsection{Erzeugung der Treelet Struktur}\label{sec:erzeugung_treelet_struktur}

Die SVO-Struktur wird schon bei der Erstellung segmentiert, das heißt, in Treelets unterteilt aufgebaut. Dies bietet die Möglichkeit bereits erzeugte Treelets auf die Festplatte auszulagern, sollte der Ar\-beits\-speicher nicht ausreichen um die erzeugten Daten zu halten. Im Folgendem soll ein Überblick über den Ablauf der Erstellung einer SVO-Struktur aus Treelets gegeben werden. In den folgenden Abschnitten werden die einzelnen Schritte genauer betrachtet.\\\\
Als Eingabe werden zunächst die gewünschte, minimale Tiefe des resultierenden Octrees, die Speichergröße der Treelets und der Pfad zu den Eingabedaten benötigt. Der Build-Manager erstellt ein initiales, leeres Treelet (\textit{Wurzel-Treelet}) und übergibt dieses an den Treelet-Builder. Dieser füllt das Treelet anhand der Eingabedaten. Anschließend werden alle entstandenen Blatt-Knoten, die noch nicht die gewünschte, minimale Tiefe in der Octree-Struktur aufweisen, notiert. Zu jedem dieser Blattknoten wird eine Liste der in ihm liegenden Primitive der Eingabedaten gespeichert. Zusätzlich wird auch seine Tiefe im Baum und seine Transformation relativ zum Wurzelknoten notiert. Außerdem wird jeweils der Treelet-Index, der Index des Blattknotens und dessen Elternknotens gespeichert um die Verknüpfung der Treelets realisieren zu können (vgl. Abschnitt \ref{sec:segmentierung} \nameref{sec:segmentierung}, Seite \pageref{sec:segmentierung}).
Der Build-Manager speichert diese Informationen in einer Queue und erzeugt für jeden Eintrag ein neues Treelet (\textit{Top-Down}). Diese werden durch die gespeicherten Treelet- und Blattknotenindices des Wurzel-Treelets initialisiert und sind so logisch mit diesem verbunden. Jedes dieser Treelets wird wiederum dem Treelet-Builder übergeben, der sie anhand seiner Primitivliste und der gespeicherten Transformation füllt. Der Build-Manager erzeugt sukzessiv weitere Treelets aus Blattknoten bereits erstellter Treelets bis die geforderte minimale Tiefe des Octrees für alle Blattknoten erreicht ist.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.83\textwidth]{figures/treelet_building.pdf}
  \caption{Schrittweiser Aufbau der SVO-Struktur aus Treelets \label{fig:treelet_building}}
\end{figure}
\newpage
Für Blattknoten mit ausreichender Tiefe erzeugt ein Attributgenerator die gewünschten Attribute und speichert diese in einem zusätzlichen Buffer. Die Primitiv\-liste und alle weiteren Informationen die zur Erstellung weiterer Treelets benötigt würden können an dieser Stelle verworfen werden. Abbildung \ref{fig:treelet_building} zeigt den schrittweisen Aufbau eines Octrees aus Treelets.\\
Ist die Erstellung der Treelets abgeschlossen werden die Attribute der inneren Knoten durch Mitteln der Attribute ihrer Untergeordneten Knoten erstellt. Dies geschieht für alle Treelets in umgekehrter Reihenfolge ihrer Erstellung (\textit{Bottom-Up}). So wird sichergestellt, dass der Wurzelknoten eines untergeordneten Treelets bereits Attributinformation enthält wenn sein übergeordnetes Treelet diese zur Generierung seiner Attribute in seinen Blattknoten benötigt. Ist die Erstellung der Attribute bis in den Wurzelknoten des Wurzel-Treelets vorangeschritten ist die Erstellung des Octrees abgeschlossen. 




%/////////////////////////////////////////////////////////



\subsection{Treelet Aufbau}
Der Treelet-Builder erstellt die Knoten in der Breite (\textit{Breadth-First}) und arbeitet dazu intern auf einem FIFO-Kontainer (\textit{Queue}). Der Aufbau eines Elementes dieser Queue ist im Listing \ref{lst:queueelement} zu sehen. Jedes Element der Queue entspricht einem Knoten in der SVO-Struktur und enthält einerseits alle Informationen die nötig sind diesen Knoten seinem übergeordneten Knoten mitzuteilen und andererseits die Erzeugung weiterer Unterknoten zu ermöglichen.

%\begin{figure}[position=h width=0.75\textwidth]
%  \centering
\begin{lstlisting}[caption={Queue-Element},label={lst:queueelement}]
struct QueueElement
{
  // Knoten-Index des Knotens innerhalb des Treelets
  unsigned              _localLeafIndex;         
  // Kind-Index des Knotens innerhalb seines Eltern-Knotens
  char                  _idx;                    
  // Knoten-Index des Eltern-Knotens
  unsigned              _parentLocalNodeIndex;   
  // Tiefe des Knotens in der SVO-Struktur
  unsigned              _depth;                  
  // Transformation des Knotens relativ zum Wurzelknoten
  gloost::Matrix        _aabbTransform;          
  // In diesem Knoten enthaltene Primitive der Ausgangsdaten
  std::vector<unsigned> _primitiveIds;           
};
\end{lstlisting}
%\end{figure}
Initial wird ein Queue-Element stellvertretend für den Wurzelknoten des aktuellen Treelets erstellt. Dieses enhält die relative Transformation dieses Knotens in der SVO-Struktur sowie alle Primitive die in diesen Knoten liegen. Für jeden potentiellen Kind-Knoten wird ein Queue-Element mit entsprechenden Parametern erzeugt und dessen \textit{Bounding Box} mit  Primitiven des aktuellen Queue-Elementes zum Schnitt gebracht. Dabei wird für jedes Kind die Untermenge an Primitiven notiert die geschnitten wurden. Falls ein Kindknoten keine Primitive enthält, wird es verworfen. Die anderen Kindknoten bekommen aufeinanderfolgende Speicherpositionen innerhalb des Treelets. Der \textit{First-Child-Index} des Knotens des aktuellen Queue-Elementes wird daraufhin auf die Position des ersten Kindes gesetzt und die Queue-Elemente der Kindknoten in die Queue eingereiht.\\
Vor dem Abarbeiten eines Queue-Elementes wird überprüft, ob im Treelet noch genügend freie Plätze für eine weitere Unterteilung vorhanden ist. Sind weniger als acht Plätze übrig muss nach der nächsten Unterteilung erst überprüft werden, ob die entstanden Kindknoten noch abgelegt werden können, bevor die Unterteilung gespeichert werden kann.  Geht dies nicht, wird versucht einen Queue-Element zu finden, dessen Bearbeitung weniger neue Knoten erzeugt. Kann kein Queue-Element gefunden werden, ist die Erstellung des Treelets abgeschlossen.\\
Die in der Queue verbliebenen Elemente werden nach ihrer Baumtiefe in finale und weiter zu unterteilende Elemente getrennt und in zwei Kontainern im Treelet gespeichert. Nachdem die finalen Knoten in den Leaf-Masks der Eltern-Knoten als solche markiert wurden, wird das Treelet an den Build-Manager zurückgegeben.\\\\
Der Build-Manager erzeugt für jedes nicht finale Queue-Element ein weiteres Treelet. Der Indices der neu erstellten Treelets werden im \textit{First-Child-Index} der zugehörigen Blattknoten des übergeordneten Treelets gespeichert. Dann werden die Treelets entsprechend parametrisiert in einer eigenen Queue einge\-reiht um sie in entsprechender Reihenfolge an den Treelet-Builder weitergeben zu können. Der oben beschriebene Ablauf wiederholt sich daraufhin für jedes Treelet in der Queue. Liefert der Treelet-Builder nur noch Treelets mit finalen Blattknoten, leert sich die Queue und das Erstellen der SVO-Struktur ist abgeschlossen. 


%/////////////////////////////////////////////////////////


\subsection{Attribut Generierung}
Zu jedem Treelet werden parallel ein oder mehrere Buffer mit verschachtelten (\textit{interleaved}) Attributinformationen erstellt. Anzahl und Layout der Attribut-Buffer sind abhängig vom gewählten Attribut-Generator.\\
Für jeden finalen Blattknoten wird mit Hilfe der gespeicherten Primitive und Transformation eine Menge von Attributen erzeugt. Dieser Vorgang soll im Folgenden am Beispiel von Dreiecks\-primitiven erläutert werden. Für jedes Dreieck innerhalb eines Blatt-Knotens wird ein Strahl erzeugt, der durch die Voxel\-mitte und senkrecht zum Dreieck verläuft (vgl. Abbildung \ref{voxel_primitiv_schnitt}a). Der Strahl wird mit den Dreiecken geschnitten um so eine UV-Koordinate berechnen zu können.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.85\textwidth]{figures/voxel_primitiv_schnitt.pdf}
  \caption{Ermittlung von UV-Koordinaten\label{voxel_primitiv_schnitt}}
\end{figure}
Durch die Wahl der Richtung ist gewährleistet, dass der Winkel zwischen Strahl und Dreicks\-fläche maximal ist, so dass die Wahrscheinlichkeit eines Schnittes erhöht wird. Trotzdem ist es möglich, dass der Strahl das Dreieck verfehlt, da das Voxel das Dreieck bei\-spiels\-weise nur mit einer Ecke schneidet, die nicht zur Voxel-Mitte ausgerichtet ist (vgl. Abbildung \ref{voxel_primitiv_schnitt}b). Um trotzdem den Beitrag des Dreiecks zu den Voxel-Attributen berücksichtigen zu können,  wird in diesem Fall der Punkt auf dem Dreieck als Schnittpunkt angenommen, der den kleinsten Abstand zum Schnittpunkt mit der Dreiecksebene besitzt. Dieser Vorgang erzeugt ein Rauschen in den Daten das aber angesichts der geringen Größe der Blatt-Knoten und des daraus resultierenden geringen Fehlers nicht sichtbar ist. Mit Hilfe der ermittelten UV-Koordinaten können nun Attribute wie Farbe oder Richtung aus den Eckpunkten der Dreiecke interpoliert oder aus Texturen gelesen werden. Die erhaltenen Werte werden über alle am Voxel beteiligten Dreiecke gemittelt. Farb- und Richtungs\-werte werden auf 8 Bit pro Komponente quantisiert bevor sie in den Attributbuffer gespeichert werden.\\
\newpage
Wie in Abschnitt \ref{sec:erzeugung_treelet_struktur} beschrieben, werden die Attribute der inneren Knoten erst erzeugt, nachdem die Erstellung aller Treelets ab\-ge\-schlos\-sen ist. Durch die Verwendung eines FIFO-Kontainers im Build-Manager sind die Treelets so nummeriert, dass jedes Treelet einen niedrigeren Index besitzt als seine untergeordneten Treelets. Somit ist das Treelet mit dem höchsten Index von keinem anderen Treelet für die Generierung seiner Attribute abhängig, da es schon in allen seinen Blatt-Knoten Attribute besitzt. Das Treelet mit dem Index $0$ ist dagegen für seine Attributgenerierung von allen anderen Treelets abhängig. Für die Generierung der Attribute werden die Treelets daher in umgekehrter Reihenfolge ihrer Indizierung abgearbeitet. Abbildung \ref{attribute_generation} veranschaulicht die Reihenfolge anhand eines Beispiels (vgl. Abbildung \ref{fig:treelet_building}).
\begin{figure}[position=v]
  \centering
  \includegraphics[width=0.70\textwidth]{figures/attribute_generation.pdf}
  \caption{Reihenfolge der Erzeugung der Attributen innerer Knoten\label{attribute_generation}}
\end{figure}\\
Beginnend beim Treelet mit dem größten Index wird jedes Treelet, vom Wurzelknoten an, der Tiefe nach, rekursiv durchlaufen bis die Blattknoten erreicht werden. Diese enthalten bereits Attribute\-informationen. Beim Aufsteigen aus der Rekursion werden die Attribute der jeweils vorhandenen Kindknoten gemittelt und im Attribut-Buffer abgelegt. Dazu werden die mit 8 Bit  aufgelösten Attribut\-komponenten der Kindknoten zunächst wieder in 32 Bit Fließ\-komma\-werte konvertiert, damit sich bei der Mittelung der Kindknotenattribute die Quantisierungsfehler nicht verstärken. Nachdem auch für den Wurzelknoten ein Attribut vorhanden ist, wird dieses in den Attribut-Buffer des übergeordneten Treelets für den entsprechenden Blattknoten abgelegt. Durch die Reihenfolge der Indizierung ist für jedes Treelet sichergestellt, dass für alle Blatt\-knoten Attributinformationen vorhanden sind wenn sie zur Generierung der Attribute der inneren Knoten benötigt werden.



