\chapter{Repräsentation und Verwendung von Volumendaten in der Computergrafik}


\section{Volumendaten}

Volumendaten können durch dreidimensionale, äquidistante Gitter beschrieben werden. Die Kreu\-zungs\-punkte der Gitter werden \textit Voxel (Volumen-Pixel) genannt. Jeder Voxel kann einen einzelnen skalaren Wert, wie beispielsweise Dichte oder Druck, oder mehrere skalare Werte wie Farben und Richtungsinformationen enthalten. Dadurch eignet sich diese Darstellung zur Repräsentation eines äquidistant ge\-sampel\-ten Raumes, der nicht homogen gefüllt ist. Durch die uniforme Unterteilung des Raumes ist die Position und die Ausdehnung eines jeden Voxels implizit in der Datenstruktur enthalten und muss daher nicht gespeichert werden. Volumendaten werden vorwiegend in der Medizin, beispielsweise als Ausgabe der Magnet\-resonanz\-tomographie oder in der Geologie zum Abbilden der Ergebnisse von Reflexions\-seismik\-verfahren verwendet.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.32\textwidth]{figures/cut_volume.pdf}
  \caption{Schnitt durch ein Volumen Gitter \label{cut_volume}}
\end{figure}
Abbildung \ref{cut_volume} zeigt einen Schnitt durch einen Volumedatensatz mit eine Auflösung von $16^3$ Voxeln.\\
Um eine hinreichende Auflösung der Volumenrepräsentation zu gewährleisten sind große Datenmengen erforderlich. Ein mit $512^3$ Voxeln aufgelöstes Volumen, dessen Voxel jeweils einen mit 4 Byte abgebildeten Skalar enthalten, belegt bereits 512 Megabyte. Verdoppelt man die Auflösung auf $1024^3$ Voxel verachtfacht sich der Speicherbedarf auf 4 Gigabyte. Volumendaten enthalten in der Regel einen großen Anteil an homogenen Bereichen die durch ein reguläres Gitter als viele Einzelwerte abgebildet werden müssen. Daher gibt es Datenstrukturen die ausgehend von dem regulären Gitter eine hierarchische Struktur erzeugen um diese Bereiche zusammenzufassen.


%  ////////////////////////////////////////////////////////////////////


\subsection{Octrees}
Ein Octree ist eine raumteilende, rekursive Datenstruktur. Ein initiales, kubisches Volumen wird in acht gleich große Untervolumen geteilt. Die Teilung wird für jedes Untervolumen fortgeführt bis eine maxi\-male Tiefe, be\-ziehungs\-weise ein maximaler Unterteilungsgrad erreicht ist. Mit jeder Tiefen\-stufe des Octrees verdoppelt sich die Auflösung der abbildbaren Information auf jeder Achse. Die Größe eines Voxels kann mit $ 2^{-d} $ bestimmt werden wobei $d$ die Tiefe des Voxels in der Baumstruktur, beginnend mit $d=0$ für die Wurzel, ist. Für vollbesetzte Octrees lässt sich eine Darstellungsvorschrift im Speicher aus der Struktur des Octrees ableiten. Da jeder Elternknoten genau acht Kinder besitzt kann innerhalb einer seriellen Struktur implizit auf seine Kind\-knoten geschlossen werden. Die Positionen der Kinder eines Knotens kann durch die Funktion $ C(P,n) = 8*P+n $ berechnet werden, wobei $P$ der Index des Elternknotens, $n$ die Nummer des Kindes (beginnend mit 1) und das resultierende $C$ der Index des Kindknotens ist. 
\begin{figure}[H]
  \centering
  \includegraphics[width=0.32\textwidth]{figures/cut_octree.pdf}
  \caption{Schnitt durch einen Octree \label{cut_octree}}
\end{figure}
Bereiche in Volumen\-daten die homogene Daten enthalten oder leer sind können von der Unterteilung ausgeschlossen werden, wodurch eine wesentlich kompaktere Darstellung der Daten gegenüber konventionellen Volumendaten erreicht werden kann. Dafür muss für jedes Voxel ein Verweis auf die ihn unterteilenden Untervolumen existieren. In der Regel besitzt jedes Voxel eines solchen Octrees acht Kinder (\textit{innerer Knoten}) oder kein Kind (\textit{Blatt-Knoten}). Im ungünstigsten Fall müssen dazu sieben leere Knoten gespeichert werden. Diese sind bei dieser Darstellung nötig um homogene Bereiche innerhalb des Eltern-Voxels zu kodieren. Abbildung \ref{cut_octree} zeigt einen Schnitt durch einen Octree der die Volumendaten aus Abbildung \ref{cut_volume} abbildet.\\ 
Jedes Voxel kann einen oder mehrere Skalare speichern. Oft werden diese Werte nicht direkt im Octree abgelegt, um bei der Traversierung der Struktur möglichst wenig Speicher auslesen zu müssen. Stattdessen werden die Attributwerte in einem zusätzlichen Attribut-Buffer abgelegt. In diesem wird für jedes Voxel im Octree ein Tupel mit Attributwerten vorgehalten. Die Attribute eines übergeordneten Voxels ergeben sich im einfachsten Fall aus dem Mittelwert der Attribute seiner untergeordneten Voxel, vergleichbar mit der Erzeugung von \textit{Mipmaps}. Somit enthält jedes Voxel seiner Größe entsprechend aufgelöste Attribut\-werte. Diese approximieren die Ausprägungen der Attribute innerhalb der räumlichen Ausdehnung des Voxels. Der Octree bildet also zugleich Geometrie und Textur ab. Der wesentliche Vorteil der Octree-Struktur gegenüber texturierten Dreiecksnetzen ist, dass sich mit dieser Struktur das LOD-Problem für Geometrie und Attribute (Texturen) gleichzeitig lösen lässt. Der hierarchische Aufbau und die Granularität von Octress ermöglichen eine effiziente Bestimmung der für die Darstellung optimalen Detailstufe der Daten. Dies kann während der Bildsynthese durch die Wahl der Traversierungstiefe im Baum pro Bildpunkt geschehen.

\subsubsection{Verwandte Arbeiten}
Crassin et al. \cite{Crassin2009} beschrieben eine Out-of-Core-unterstütztes System bei dem kleine Voxel-Vo\-lu\-men in einer Octree-Struktur angeordnet werden. Der Octree dient dabei zum effizienten Speichern von Volumen\-daten mit großen homogenen Bereichen. Um inhomogene Bereiche innerhalb der Volumendaten zu fin\-den wurde der Octree mit den Sichtstrahlen geschnitten. Wird ein solcher Bereich gefunden wird dessen Beitrag zum Bild durch Volumen-Raycasting bestimmt. Dazu wird die hardwaregestützte, trilineare Filterung von Grafikkarten ausgenutzt.



%  ////////////////////////////////////////////////////////////////////



\subsection{Sparse Octrees}
Für einige Anwendungen sind nur bestimmte Ausprägungen der in den Voxeln gespeicherten Werte von Interesse. Beispielsweise werden beim Iso-Surface-Rendering nur Voxel mit einen bestimmten Dichte\-wert als opake Oberfläche dargestellt. Werden nur diese Werte benötigt kann die Datenstruktur weiter ausgedünnt werden indem nur Voxel gespeichert werden, die zur Oberfläche beitragen.
\begin{figure}[H]
  \centering
  \includegraphics[width=0.32\textwidth]{figures/cut_svo.pdf}
  \caption{Schnitt durch einen Sparse Voxel Octree \label{cut_svo}}
\end{figure}
Eine solche Volumenrepräsentation eignet sich ebenso zur Darstellung anderer opaker Oberflächen wie diskretisierter Dreiecksnetze, Punktwolken oder Höhenfeldern und wird als \textit{Sparse Octree} oder \textit{Sparse Voxel Octree} bezeichnet. Innere Knoten können dabei weniger als acht Kindknoten besitzen. Durch die variierende Anzahl von Kindknoten lässt sich keine implizite Regel zum Berechnen ihrer Positionen im Speicher herleiten. Vielmehr muss jeder Knoten speichern welche Kindknoten besetzt sind und wo sich diese im Speicher befinden. Liegen die Kindknoten jedes Voxels jeweils hintereinander im Speicher, muss jedoch nur ein Verweis pro Elternknoten vorgehalten werden. Da in einem Sparse Voxel Octree nur Oberflächen gespeichert werden, steigt der Speicherbedarf mit jeder weiteren Tiefenstufe nur durchschnittlich um das vierfache, wie unter anderem in \cite{Laine2010} gezeigt werden konnte. Abbildung \ref{cut_svo} zeigt den Schnitt durch einen Sparse Voxel Octree der die Oberflächen der Volumen\-daten aus Abbildung \ref{cut_volume} speichert.
\\
\subsubsection{Verwandte Arbeiten}
In der Arbeit von Lacoste et al. \cite{Lacoste_2007} werden Sparse Octrees verwendet, um Ober\-flächen\-normalen eines hoch\-auf\-gelösten Dreiecksnetzes zu speichern. Dabei wird die Unterteilung der Knoten in Abhängigkeit von der Auflösung der Oberflächendetails vorangetrieben. Bei der Darstellung einer niedriger aufgelösten Version des Netzes werden die im Octree enthaltenen Werte dazu verwendet, den ursprünglichen Detailgrad des Modells zu rekonstruieren. Diesen erhält man während der Rekonstruktion durch Wahl der Octree-Tiefe in Abhängigkeit vom Abstand der Kamera zum betrachteten Objekt\-punkt. Dies führt zu einem mit dem Mipmapping vergleichbaren Ergebnis. Dabei verlangt dieser Ansatz keine Parametrisierung des Drei\-ecks\-netzes.
\\
\\
Laine et al. \cite{Laine2010} stellte die bisher umfangreichste Arbeit über Sparse Voxel Octrees vor. Wie auch in der Arbeit von Plate et al. \cite{Plate2002} spei\-chert jeder Knoten im Octree einen Verweis auf den ersten Kindknoten und Bitmasken welche die Konfiguration der möglichen Kindknoten beschreiben. Neben einem sehr effizienten Raycasting-Ansatz beschreibt die Arbeit unter anderem Techniken zur Kompression von Normalenwerten und der Nutzung von Kontur\-informationen zur besseren Approximation des Oberflächen\-verlaufs der dargestellten Geometrie. Zu\-sätz\-lich beschreibt die Arbeit einen effizienten Out-of-Core-Ansatz. Im Gegensatz zu dem, in der vorliegenden Arbeit beschriebenen Out-of-Core-Ansatz, arbeitet dieser aus\-schließ\-lich auf der CPU. Dabei wird eine Heuristik verwendet, um anhand der Auflösung der bisher geladenen Segmente und der aktuellen Ansicht, mögliche neue Segmente anzufordern.
\\
\\
In einer weiteren Arbeit von Crassin et al. \cite{CNSGE11b} wird eine dynamisch erstellte Sparse-Voxel-Octree-Re\-präsen\-tation der Szenen\-geometrie verwendet um globale Beleuchtungswerte für alle Oberflächen zu speichern. Während der Bilderzeugung durch Rasterisierung kann damit durch Verwendung von Cone Tracing zwei Reflektionstiefen für den direktionalen Lichtanteil, in echtzeitfähigen Bild\-wieder\-holraten, berechnet werden. Um auch dynamische Dreiecks\-netze unterstützen zu können wird die Octree-Reprä\-sentation der Szenengeometrie für jedes Bild neu erstellt.


%  ////////////////////////////////////////////////////////////////////


\section{Raycasting von Volumendaten}
Bei Raycasting wird für jeden Punkt eines Ziel-Buffers ein Strahl erzeugt und mit den Volumen\-daten geschnitten. 
Volumen\-gitter können dazu beispielsweise in festen Abständen durchschritten werden, um Dichtewerte zu ermitteln und über eine Transfer\-funktion abzubilden (vgl. Drebin et al. \cite{Drebin:1988:VR:378456.378484}). Dabei müssen auch Be\-rei\-che des Volumens verarbeitet werden, die leer sind und nicht zum Bildinhalt beitragen (vgl. Lichtenberg et al. \cite{LCN98}).\\
In der Octree-Darstellung können große, homogen gefüllte Bereiche übersprungen werden. Dies wird erreicht, indem  der Strahl mit dem Voxel geschnitten wird, das diesen Bereich umgibt, um so einen Eintritts- sowie einen Austritts\-punkt zu ermitteln. Der hierarchische und reguläre Aufbau des Octrees ermöglicht es, die Anzahl der dazu notwendigen Schnitt\-berechnungen zu minimieren und diese effizient durchzuführen. Durch eine Tiefen\-suche im Baum kann in jeder Tiefe das den Strahl zuerst schneidende Voxel ermittelt werden. Da die Voxel ihre Position und Größe nur implizit über ihre Lage im Baum erhalten, müssen diese Werte beim Traversieren für jeden Voxel berechnet werden.\\
\\
Ein Strahl kann durch $p_t(t)=p+td$ beschrieben werden. Löst man die Gleichung nach $t$ für eine achsen\-parallele Ebene, erhält man $t_x(x) = (\frac{1}{d_x})x+(\frac{-p_x}{d_x})$. Die Werte für  $\frac{1}{d_x}$ und $\frac{-p_x}{d_x}$ können für jeden Strahl vorberechnet werden wodurch sich der Schnitt zwischen Strahl und Ebene auf eine Multiplikation und eine Addition reduzieren lässt. Abbildung \ref{raycasting} zeigt auf der linken Seite den Schnitt eines Strahles mit den achsenparallelen Ebenen der Kindknoten bei $x_0$, $x_1$, $x_2$ und $y_1$. Der Eintrittspunkt des Strahls in den Elternknoten kann über die Länge $t_{min} = max(t_x(x_0),t_x(y_0),t_x(z_0)$ und die Strahlengleichung berechnet werden. Der Austrittspunkt kann durch Einsetzen von $t_{max} = min(t_x(x_1),t_x(y_1),t_x(z_1)$ in die Strahlengleichung berechnet werden.\\
Der Baum wird durch Tiefen\-suche traversiert um den ersten Schnittpunkt des Strahles mit der im Octree abgebildeten Struktur zu fin\-den. Abbildung \ref{raycasting} zeigt auf der rechten Seite die Reihenfolge der Abarbeitung einer Voxel-Hierarchie.


\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/raycasting.pdf}
  \caption{Bestimmung der Reihenfolge der Kindknoten beim Schnitt \label{raycasting}}
\end{figure}


%\subsubsection{Verwandte Arbeiten}
%In Buch von \cite{LCN98}  asdadsad


%  ////////////////////////////////////////////////////////////////////




