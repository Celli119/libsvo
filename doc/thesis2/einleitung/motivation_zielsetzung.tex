\chapter{Einleitung}
\section{Motivation}
Seit ihrer Vorstellung in den 70er Jahren ist die Bild\-synthese durch Ras\-teris\-ierung von pa\-rame\-tri\-sierten Dreiecken der Quasi-Standard für Echtzeitcomputergrafik. Diese Entwicklung wurde nicht zuletzt durch die Einführung von dedizierter Hardware und offenen Standards, wie OpenGL möglich. Der Vorteil von Dreiecken als Geometrieprimitiv ist, dass sich mit ihnen sehr effizient planare Flächen darstellen lassen. Dabei hat die Größe der abgebildeten Flächen keinen Einfluss auf den Speicherbedarf der Repräsentation. In modernen Anwendungen, wie Spielen oder bei der Darstellung von hochauflösenden 3D-Scanns ist dieser Vorteil jedoch immer weniger relevant, da der überwiegende Teil des benötigten Speichers durch Texturen belegt wird. Diese werden benötigt, um die Flächen mit Details zu versehen, wie Farbe, Richtung und anderen zur Beleuchtung benötigten Attributen. Dabei ist die Parametrisierung von komplex geformten Dreiecksnetzen mit Textur\-koordinaten nicht trivial und muss meist händisch bewerkstelligt werden.\\
Bei der Rasterisierung von detaillierten Dreiecksnetzen mit hochaufgelösten Texturen kommt es zu Aliasing\-artefakten. Um diese zu reduzieren, werden von Dreiecksnetz und Texturen niedriger aufgelöste, statische Versionen erzeugt (\textit{Level-of-Detail, LOD}). Zwischen diesen wird bei der Darstellung je nach Betrachtungsabstand gewechselt, was zu störenden \textit{Popping}-Artifakten führt wenn eine LOD-Stufe durch eine andere ausgetauscht wird. Mit dieser Technik kann nur im seltensten Fall, ein ideales Verhältnis zwischen Geometrie- und gegebener Bildauflösung, gewährleistet werden. Dynamische Erzeugung von LOD-Stufen ist mit hohen Rechen- oder Speicheraufwand verbunden. Außerdem muss das LOD-Problem für Geometrie und Texturdaten während der Erstellung und der Darstellung, separat gelöst werden. Ein Nachteil des Rasterisierungsansatzes ist das Fehlen von globalen Informationen während der Fragmentgenerierung. Jedes Primitiv wird für sich behandelt ohne das globale Informationen zur Optimierung (\textit{Culling}) oder Beleuchtung (\textit{Global Illumination}) zur Verfügung stehen.\\
\begin{figure}[position=h]
  \centering
  \includegraphics[width=1.0\textwidth]{figures/mesh_and_svo.png}
  \caption{Mesh und Sparse Voxel Octree \label{mesh_and_svo}}
\end{figure}
Die Generalisierung der Renderpipelines und die Einführung von GPGPU-Hochsprachen wie OpenCL machen es möglich die Frage nach geeignetem Geometrieprimitiv und Bildsyntheseverfahren neu zu stellen. Sparse Voxel Octree als Datenstruktur in Kombination mit \textit{Raycasting} als Algorithmus zur Bildsynthese bieten viele positive Eigenschaften. So vereinen Sparse Voxel Octrees Geometrie und Texturdaten in einer einzigen hierarchischen Datenstruktur. Durch Raycasting auf dieser Struktur kann das LOD-Problem von Geometrie und Textur gemeinsam pro Bildpunkt gelöst werden. Gleichzeitig wirkt der Octree als Beschleunigungsstruktur, so dass während des Traversierens nur die Teile der Struktur durchlaufen werden, die zur Bildsynthese beitragen. Eine Parametrisierung ist nicht notwendig, da jedes Voxel seine eigenen Attributinformationen spei\-chert, die für seine Größe in optimaler Auflösung vorliegen.\\
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.8\textwidth]{figures/eye_mesh_and_svo.png}
  \caption{Detail: Mesh und Sparse Voxel Octree \label{eye_mesh_and_svo}}
\end{figure}
Dennoch gibt es einige Herausforderungen die vor der Verwendung von Sparse Voxe Octrees bewältigt werden müssen. Sparse Voxel Octrees benötigen viel Speicher. Die Menge an Arbeitsspeicher aktueller Grafikkarten genügt, um eine SVO-Struktur in relativ hohen Auflösung zu speichern, die für einige Anwendungen genügt. Benötigt man jedoch höhere Auflösung um möglichst viele Details bzw. sehr große Strukturen abbilden zu können, fallen leicht mehrere Gigabyte an Daten an, die nicht mehr als Ganzes in den GPU-Speicher passen.\\
Da Sparse Voxel Octrees erst in jüngster Zeit in den Fokus von Wissenschaft und Industrie gerückt sind, sind sie in Programmen zur Erstellung von 3D-Inhalten noch nicht angekommen. Daher ist es zunächst notwendig Sparse-Voxel-Octrees-Strukturen aus anderen Geometrie\-repräsentationen zu erstellen. Dreicksnetze, Punktwolken, Höhenfelder oder Volumen können als Eingabedaten dienen. Um unterschiedliche Repräsentationen von Inhalten, ohne großen Entwicklungsaufwand, unterstützen zu können fehlt ein generisches System das diese Daten verarbeiten kann.


!!! SCREENSHOT david face dreicke gegen voxel



\section{Zielstellung}
In der vorliegenden Arbeit ...



\textbf{Zeilstellung 2:} Entwicklung eines Out-Of-Core Ansatzes basierend auf Segmentierung der SVO Daten und adaptives refinement

\textbf{Zeilstellung 1:} Entwicklung eines Templates zur Generierung von SVO aus unterschiedlichen Datenvorlagen (Dreiecke, Pointclouds, Heightmaps, volumen).\\
\\
  
  