
\section{Echtzeitfähiges Sparse Voxel Octree Ray Casting}\label{sec:echtzeitfaehiges_svo_raycasting}


\subsection{Prinzipieller Aufbau}

Der in dieser Arbeit verwendete Out-Of-Core-Ansatz besteht grundsätzlich aus vier Teilen (Abbildung \ref{out-of-core_setup}): Einem großen, clientseitigen \textbf{Segmentpool} der die gesamte SVO-Struktur vorhält, einem vergleichsweise kleinen Buffer der eine Untermenge der SVO-Struktur halten kann und auf Server- und Clientseite existiert (\textbf{\textit{Incore-Buffer}}), einer \textbf{Speicherverwaltung} die den server-seitigen Buffer pflegt und einem \textbf{Analysesystem} das entscheidet welche Segmente benötigt werden.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.85\textwidth]{figures/out-of-core_setup.pdf}
  \caption{Schematischer Aufbau des Out-Of-Core-Systems\label{out-of-core_setup}}
\end{figure}
Der Incore-Buffer, der auf Client- und Serverseite vorhanden ist, wird wie der SVO in Segmente gleicher Größe (\textbf{\textit{Slots}}) aufgeteilt, von denen jeder ein Treelet aufnehmen kann. Die Wahl einer einheitliche Treelet- und Größe verhindert somit Fragmentierung des Incore-Buffers und somit den Defragmentierungs\-aufwand. Die Analyse arbeitet serverseitig auf den im Incore-Buffer vorhandenen Treelets. (!!! WEITER)



% ////////////////////////////////////////////



\subsection{Überblick der Verarbeitungsschritte}
Im Folgenden soll der Ablauf der dynamischen Veränderung der SVO-Struktur im Incore-Buffer, abhängig von der Kameraposition erläutert werden. In den nachfolgenden Kapiteln wird auf die einzelnen Schritte genauer eingegangen.\\
Der Incore-Buffer wird zunächst mit dem Wurzel-Treelet im ersten Slot initialisiert. Die adaptive Anpassung der Baumstruktur wird in vier Schritten realisiert: Zunächst wird der Octree aus der Sicht der Kamera in den Feedback-Buffer gerendert (\textbf{\textit{Analyse-Pass}}). Nach diesem Schritt enthält dieses Buffer für jeden Strahl unter anderem die Position des getroffenen Knoten im Incore-Buffer und einen Fehlerwert. War der getroffene Knoten ein Blatt, zu dessen Verfeinerung ein Treelet vorhanden ist, wird zusätzlich noch dessen Index gespeichert.\\
Nach der Übertragung des Feedback-Buffers in den Hauptspeicher werden dessen Einträge in zwei Container einsortiert (\textbf{\textit{Vorsortierung}}). Der eine enthält die Treelet-Indices aller Knoten die sichtbar sind sowie die Treelet-Indices ihrer übergeordneten Treelets bis zum Wurzel-Treelet. Der andere Container enhält Anfragen nach Verfeinerung in Form der Treelet-Indices der anzuhängen Treelets. Die Fehlerwerte bleiben dabei in beiden Containern erhalten.\\
Beide Container werden dem Speichermanagement übergeben (\textit{\textbf{clientseitige Aktualisierung}}). Dort werden zunächst die Sichtbarkeitsinformationen aller im letzten Zyklus sichtbarer Treelets aktualisiert. Danach werden die neu anzuhängenden Treelets in den clientseitigen Incore-Buffer eingepflegt. Stehen im Incore-Buffer keine freien \textit{Slots} mehr zur Verfügung, werden nicht sichtbare Treelets entfernt. Geänderte Slots werden markiert. Abschließend werden die veränderten Bereiche des Incore-Buffers an den Server übertragen und stehen nun dem Renderer für den nächsten Zyklus zur Verfügung (\textbf{\textit{serverseitige Aktualisierung}}).\\
Die folgenden Abschnitte werden diese Schritte genauer betrachten.



% ////////////////////////////////////////////



\subsection{Analyse-Pass}\label{sec:streaming_analyse_pass}

Um die Last, die durch diesen zusätzlichen Render-Pass entsteht, möglichst gering zu halten ist die Größe des zur Analyse verwendeten Zielbuffer wesentlich kleiner als die des für die Bildgenerierung verwendeten Frame-Buffers. Um Artefakt\-bildung zu vermindern werden die Strahlen bei jedem Analyseschritt durch Zufalls\-werte parallel zur Sicht-Ebene verschoben. Die Verschiebung ist dabei so gewählt das über die Zeit im Bereich von $n*n$ Texeln des Bild-Buffers wird, wobei $n$ das Verhältnis der Größen von Frame-Buffer und Analyse-Buffer ist.
In Tests war es möglich den Analyse-Buffer bis auf $1/8$ der Größe des Bild-Buffers zu verkleinern ohne dass es durch Aliasing zu Artefaktbildung kam oder zu wenig Daten für die nachfolgende dynamische Anpassung des Octrees zur Verfügung standen.\\

Das Füllen des Feedback-Buffers erfolgt analog zum bilderzeugenden Raycasting in OpenCl auf dem im Incore-Buffer vorhanden Octree. Nach der Traversierung des Octrees liegt für jeden Strahl eines der folgenden drei Ergebnisse vor:  
\begin{enumerate}
  \item der Strahl trifft keinen Knoten 
  \item der Strahl trifft einen inneren Knoten
  \item der Strahl trifft einen Blattknoten
\end{enumerate}
Im ersten Fall wird nichts zurückgegeben. Im zweiten Fall wird nur die Position des Voxels im Incore-Buffer und die Länge des Strahles zurückgegeben. Im dritten Fall wird zusätzlich der Verweis auf ein eventuell anhängbares Treelet zurückgegeben. Ausserdem wird die Differenz zwischen vorgefundener Voxelgröße und der für die Länge des Strahles idealen Voxelgröße als Fehlerwert gespeichert.

\begin{lstlisting}[caption=Struktur eines Feedback-Elementes]{structFeedBackDataElement}
  struct FeedBackDataElement
  {
    // Knoten-Index im Incore-Buffer in dem der Strahl terminierte
    int   _nodeId;
    // Unterschied zwischen geforderter und erreichter Voxelgröße
    float _error;
    // Treelet-Index, falls der Strahl in einem Blatt terminierte
    int   _subTreeletGid;
    // Entfernung von Kamera und Knoten (nicht notwendig für den beschriebenen Ablauf)
    float _tmin;
  };
\end{lstlisting}


\subsection{Vorsortierung}\label{sec:streaming_vorsortierung}

Nach der Übertragung des Analyse-Buffers vom Server in den Hauptspeicher werden dessen Elemente ausgewertet. Dabei werden zwei Container mit unterschiedlichen Sicht\-informationen gefüllt. Im ersten Container werden Indices von Treelets notiert, die bereits im Incore-Buffer vorhanden sind, im Zweiten nur Anfragen nach neuen Treelets. Beide Container sind nach dem Fehlerwert der Einträge absteigend sortiert wobei jeder Treelet-Index über beide Container hinweg unique ist.\\
Im oben beschriebenen Fall 1 (der Strahl trifft keinen Knoten) liegt keine Sichtbarkeitsinformation vor, weshalb solche Einträge übersprungen werden. Im Fall 2 (der Strahl trifft einen inneren Knoten) wird über die erhaltene Position des Knoten im Incore-Buffer und über die Größe eines Treelets auf den \textit{Slot} des zugehörigen Treelets und damit auch auf das entsprechenden Treelet selbst geschlossen. Durch die in den Treelets gespeicherten Eltern-Information werden zusätzlich alle übergeordneten Treelets als sichtbar notiert. Tritt bei der Notation ein Treelet mehrfach auf, wird jeweils der größte Fehler übernommen.\\
Im Fall 3 (der Strahl trifft ein Blatt) wird für den Blattknotenindex wie im Fall 2 vorgegangen. Zusätzlich wird der Treelet-Index des anhängbaren Treelets im entsprechenden Container gespeichert. Tritt ein Treelet-Index mehrfach auf wird auch hier nur ein Eintrag mit dem größten Fehler gespeichert.\\
Damit ist die Trennung von Sichtbarkeitsinformation für schon im Incore-Buffer vorhandene Treelets und Anfragen nach neuen Treelets abgeschlossen. An diesem Punkt kann die Menge der Anfragen noch auf einen Maximalwert begrenzt werden um die Last für die folgenden Schritten zu begrenzen, was die Verfeinern des Octrees verlangsamt. Die absteigende Sortierung der Anfragen nach ihrem Fehler bei der Darstellung des Voxels sorgt dafür, dass bei einer Begrenzung der Menge der Anfragen immer diejenigen weiterverarbeitet werden, die den größten Beitrag zur Bildqualität liefern. Anschließend werden beide Container der Speicherverwaltung für die clientseitige Aktualisierung übergeben.



% ////////////////////////////////////////////



\subsection{Clientseitige Aktualisierung}

Nun sollen die ermittelten Sichtbarkeitsinformationen eingepflegt und Anfragen nach neuen Treelets in Veränderungen der Octree-Struktur umgesetzt werden. Nach diesem Schritt wird sich auch die Belegung des clientseitigen Incore-Buffers geändert haben.\\
Die Pflege der Sichtbarkeitsinformationen der bereits im Incore-Buffer befindlichen Treelets ist trivial: Zunächst wird die Sichtbarkeit jedes \textit{Slots}, d.h. die Sichtbarkeit jedes im \textit{Incore-Buffer} befindlichen Treelets dekrementiert. Dann wird die Sichtbarkeit derjenigen Treelets aktualisiert, die beim letzten Analyse-Pass gesehen wurden. Dabei wird die Sichtbarkeit auf einen vorher festgelegten Maximalwert gesetzt der dem Größenverhältnis von Render-Buffer und Analyse-Buffer entspricht. %Da die Anzahl der berechneten Samples im Analyse-Buffer bei einem Größenverhältnis von $1/8$ nur einem $1/64$ der berechneten Pixel im Framebuffer entspricht währe anzunehemen das die miximale Sichtbarkeitswert höher sein müsste. 

\subsubsection{Einfügen eines Treelets}
Für das Einfügen eines Treelets aus dem in der Vorsortierung erstellten Container wird zunächst ein freier Slot innerhalb des Incore-Buffers benötigt. Ist dieser vorhanden, kann das Treelet an die ensprechende Stelle im Incore-Buffer kopiert werden. Der Slot-Index wird im Treelet-Objekt gespeichert und zur Aktualisierung des serverseitigen Incore-buffers vorgemerkt. Die folgende Veränderung der Baumstruktur kann in Listing \ref{lst:insert_treelet} nachvollzogen werden. Aus dem Treelet werden folgende Informationen gelesen:
\begin{enumerate}
  \item der Treelet-Index des Eltern-Treelets
  \item der Knoten-Index des Blattes, an dem das Treelet angehängt werden soll
  \item der Eltern-Knoten-Index des Blattes
  \item die Position des Blattes in seinem Eltern-Knoten
\end{enumerate}
Damit wird nun die Position des entsprechenden Blatt\-knotens des Eltern-Treelets im Incore-Buffer ermittelt und durch den Wurzel\-knoten des anzuhängenden Treelets ersetzt. Dadurch muss dessen relative Index zu seinem ersten Kindknoten angepasst werden. Der erste Kindknoten des neuen inneren Knotens findet sich immer an zweiter Position innerhalb des angehängten Treelets im Incore-Buffer. Der Blattknoten wird damit zu einem inneren Knoten, was wiederum in seinem Elternknoten an der ensprechenden Stelle in der \textit{Child-Mask} markiert wird. In einem weiteren Container wird vermerkt, dass das Parent-Treelet nun ein neues Kind-Treelet im Incore-Buffer besitzt. Abschließend wird der Slot-Index des Parent-Treelets zur späteren serverseitigen Aktualisierung vorgemerkt. 
\lstinputlisting
    [caption={Einfügen eines Treelets}
       \label{lst:insert_treelet},
       captionpos=t,language=C++]
 {listings/insert_treelet.cpp}
 

% ////////////////////////////////////////////


\subsubsection{Entfernen eines Treelets}
Ist für das Einfügen eines Treelets kein Slot mehr verfügbar, muss zunächst ein Slot wieder freigegeben werden, dessen Treelet nicht sichbar ist. Dazu wird der Baum der Treelets nebenläufig durchsucht und eine Menge von Kandidaten für das Entfernen vorgehalten. Da diese Suche neben\-läufig geschieht ist nicht sichergestellt, dass dieser Kaditat zum Zeitpunkt des Entfernens noch valide ist. Deshalb muss vor dem eigentlichen Entfernen der Sichtbarkeitswert des Slots zunächst erneut überprüft werden. Ausserdem ist es möglich, dass zwar das entsprechende Treelet selbst nicht sichtbar war. Wird dieses Treelet jedoch Entfernts, wird der entsprechende Blatt-Knoten des Eltern-Treelets sichtbar. Dies geschieht ausnahmslos an den Rändern der Geometrie. Abbildung \ref{sichtstrahl_kanten_artefakt} stellt diesen Fall dar. Im Bild befindet sich ein geladenes Treelet hinter einer konvexen Wölbung der Geometrie und kann so nicht vom Analyse-Pass gesehen werden. Wird dieses Treelet jedoch entfernt, ragt der entstehende Blatt-Knoten des Eltern-Treelets (im Bild rot dargestellt) über die Wölbung hinaus. Im nächsten Zyklus würde dieses Blatt wieder verfeinert werden wodurch es zu flackernden Artefakten an den Geometrie\-kanten kommt. Um diese Artefaktbildung zu verhindern wird die Sichtbarkeit des Eltern-Treelets ebenfalls überprüft. Nur wenn auch das Eltern-Treelet nicht sichtbar ist, kann das Treelet sicher entfernt werden.\\
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/sichtstrahl_kanten_artefakt.pdf}
  \caption{Artefaktbildung and Objektkante\label{sichtstrahl_kanten_artefakt}}
\end{figure}
Alle Slots von im Incore-Buffer gespeicherten Treelets, die sich unterhalb des zu entfernenden Treelets befinden, können sofort freigegeben werden. Dazu wird für das Kan\-di\-daten-Treelet ermittelt, welche untergeordneten Treelets sich ebenfalls im Incore-Buffer befinden. So werden in einem günstigen Fall gleich mehrere Slots freigegeben.\\
Die Manipulation des Incore-Buffers zum Entfernen des Kan\-di\-daten-Treelets läuft analog zum Einfügen ab. Die folgenden Schritte können im Listing \ref{lst:remove_treelet} nachvollzogen werden.

\lstinputlisting
    [caption={Entfernen eines Treelets}
       \label{lst:remove_treelet},
       captionpos=t,language=C++]
 {listings/remove_treelet.cpp}


Wieder wird das Eltern-Treelet, die Position des entsprechenden Blatt-Knoten und dessen Eltern-Knotens ermittelt. Dann wird der Blattknoten durch sein Original aus dem Eltern-Treelet überschrieben. Aus dem inneren Knoten wird so wieder ein Blattknoten mit einem Verweis auf ein anhängbares Treelet. Dies wird im Elternknoten des Blattknotens an der entsprechenden Stelle in der \textit{Child-Mask} markiert. Da sich damit das Eltern-Treelet im client\-seitigen Incore-Buffer geändert hat muss dessen Slot zur server\-seitigen Aktualisierung vorgemerkt werden.

% ////////////////////////////////////////////


\subsection{Serverseitige Aktualisierung}\label{sec:serverseitige_aktualisierung}

Die beim Einfügen und Entfernen von Treelets markierten Slots werden in diesem Schritt auf den Server übertragen. Dabei kann im einfachsten Fall jeder Slot innerhalb des Incore-Buffers einzeln übertragen werden. Dies führt jedoch zu vielen Einzelübertragungen von geringer Größe. Dies ist sehr ungünstig, da für jede Kopieroperation ein erheblicher Verwaltungsaufwand innerhalb der OpenCL-Implementation anfällt. Handelt es sich beim verwendeten Server um eine GPU, müssen die Daten zusätzlich über den PCI-Express-Bus übertragen werden. Auch hier kann eine hohe Übertragungsrate nur durch möglichst große Pakete erreicht werden.\\
Um die Anzahl der Kopieraufrufe möglichst gering zu halten werden deshalb nahe aneinanderliegende Slots zusammengefasst und gemeinsam kopiert. Dazu werden die Indices der zu aktualisierenden Slots sortiert vorgehalten. Ausgehend vom ersten Slot-Index wird der zu kopierende Speicherbereich so lange bis zum nächsten Slot erweitert bis das Verhältnis zwischen zu aktualisierenden Slots und unveränderten Slots innerhalb dieses Bereiches unter einen festgelegtes Grenzwert sinkt. Abbildung \ref{zusammenfassung_der_slots} zeigt das Ergebnis dieser Zusammenfassung für ein Verhältis von 50\% zwischen veränderten Slots und Gesamtzahl der Slots im zu kopierenden Bereich.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.85\textwidth]{figures/zusammenfassung_der_slots.pdf}
  \caption{Zusammenfassen von Slots zur Übertragung\label{zusammenfassung_der_slots}}
\end{figure}
Am effizientesten arbeitet dieser Ansatz wenn der Incore-Buffer anfangs noch leer ist da die Slots-Indices aufeinanderfolgend herausgegeben werden und die entsprechenden Speicherbereiche damit an einem Stück auf den Server transferiert werden können. Das Zusammenfassen der Slots kann in einem Thread ausgelagert werden damit sich der entstehende Zeitaufwand nicht auf die Bildrate auswirkt. Im Abschnitt \ref{sec:test_zusammenfassen_von_slots} (\nameref{sec:test_zusammenfassen_von_slots}) wird die Ermittelung eines geeigneten Wertes für das Verhälnis zwischen veränderten Slots und Gesamtzahl der Slots im zu kopierenden Bereich untersucht.