\chapter{Repräsentation und Verwendung von Volumendaten in der Computergrafik}


\section{Volumendaten}

Volumendaten können durch dreidimensionale, äquidistante Gitter beschrieben werden. Die Kreuzungspunkte der Gitter werden \textit Voxel (Volumen-Pixel) genannt. Jeder Voxel kann einen einzelnen skalaren Wert, wie beispielsweise Dichte oder Druck, oder mehrere skalare Werte wie Farben und Richtungsinformationen enthalten. Dadurch eignet sich diese Darstellung zur Repräsentation eines äquidistant gesampelten Raumes, der nicht homogen gefüllt ist. Durch die uniforme Unterteilung des Raumes ist die Position und die Ausdehnung eines jeden Voxels implizit in der Datenstruktur enthalten und muss daher nicht gespeichert werden.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.32\textwidth]{figures/cut_volume.pdf}
  \caption{Schnitt durch ein Volumen Gitter \label{cut_volume}}
\end{figure}
Volumendaten werden vorwiegend in der Medizin, beispielsweise als Ausgabe der Magnet\-resonanz\-tomographie oder in der Geologie zum Abbilden der Ergebnisse von Reflexions\-seismik\-verfahren verwendet.\\
Um eine hinreichende Auflösung der Volumenrepräsentation zu gewährleisten sind große Datenmengen erforderlich. Ein mit $512^3$ Voxeln aufgelöstes Volumen, dessen Voxel jeweils einen mit 4 Byte abgebildeten Skalar enthalten, belegt bereits 512 Megabyte. Verdoppelt man die Auflösung auf $1024^3$ Voxel, verachtfacht sich der Speicherbedarf auf 4 Gigabyte. Volumendaten enthalten in der Regel einen großen Anteil an homogenen Bereichen, die durch ein reguläres Gitter als viele Einzelwerte abgebildet werden müssen. Daher gibt es Datenstrukturen, die ausgehend von dem regulären Gitter eine hierarchische Struktur erzeugen, um diese Bereiche zusammenzufassen.



%  ////////////////////////////////////////////////////////////////////


\subsection{Octrees}
Ein Octree ist eine raumteilende, rekursive Datenstruktur. Ein initiales, kubisches Volumen wird in acht gleich große Untervolumen geteilt. Die Teilung wird für jedes Untervolumen fortgeführt, bis eine maximale Tiefe, beziehungs\-weise ein maximaler Unterteilungsgrad erreicht ist. Mit jeder Tiefen\-stufe des Octrees verdoppelt sich die Auflösung der abbildbaren Information auf jeder Achse. Die Größe eines Voxels kann mit $ 2^{-d} $ bestimmt werden wobei $d$ die Tiefe des Voxels in der Baumstruktur, beginnend mit $d=0$ für die Wurzel, ist. Für vollbesetzte Octrees lässt sich eine Darstellungsvorschrift im Speicher aus der Struktur des Octrees ableiten. Da jeder Elternknoten genau acht Kinder besitzt, kann innerhalb einer seriellen Struktur implizit auf seine Kind\-knoten geschlossen werden. Die Positionen der Kinder eines Knotens kann durch die Funktion $ C(P,n) = 8*P+n $ berechnet werden, wobei $P$ der Index des Elternknotens, $n$ die Nummer des Kindes (beginnend mit 1) und das resultierende $C$ der Index des Kindknotens ist.\\
\\
Bereiche in Volumendaten, die homogene Daten enthalten oder leer sind, können von der Unterteilung ausgeschlossen werden, wodurch eine wesentlich kompaktere Darstellung der Daten gegenüber konventionellen Volumendaten erreicht werden kann. Dafür muss für jedes Voxel ein Verweis auf die ihn unterteilenden Untervolumen existieren. In der Regel besitzt jedes Voxel eines solchen Octrees acht Kinder (\textit{innerer Knoten}) oder kein Kind (\textit{Blatt-Knoten}). Die im ungünstigsten Fall zu speichernden sieben leere Knoten sind bei dieser Darstellung nötig um homogene Bereiche innerhalb des Eltern-Voxels zu kodieren.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.32\textwidth]{figures/cut_octree.pdf}
  \caption{Schnitt durch einen Octree \label{cut_octree}}
\end{figure}
Jedes Voxel kann einen oder mehrere Skalare speichern. Oft werden diese Werte nicht direkt im Octree abgelegt, um bei die Traversierung der Struktur möglichst wenig Speicher auslesen zu müssen. Stattdessen werden die Attributwerte in einem zusätzlichen Attribut-Buffer abgelegt. In diesem wird für jedes Voxel im Octree ein Tupel mit Attributwerten vorgehalten. Die Attribute eines übergeordneten Voxels ergeben sich im einfachsten Fall aus dem Mittelwert der Attribute seiner untergeordneten Voxel, vergleichbar mit der Erzeugung von \textit{Mipmaps}. Somit enthält jedes Voxel seiner Größe entsprechend aufgelöste Attribut\-werte. Diese approximieren die Ausprägungen der Attribute innerhalb der räumlichen Ausdehnung des Voxels. Der Octree bildet also zugleich Geometrie und Textur ab. Der wesentliche Vorteil der Octree-Struktur gegenüber texturierten Dreiecksnetzen ist, dass sich mit dieser Struktur das LOD-Problem für Geometrie und Attribute (Texturen) gleichzeitig lösen lässt. Der hierarchische Aufbau und die Granularität von Octress ermöglichen eine effiziente Bestimmung der für die Darstellung optimalen Detailstufe der Daten. Dies kann während der Bildsynthese durch die Wahl der Traversierungstiefe im Baum pro Bildpunkt geschehen.

\subsection{Verwandte Arbeiten}



%  ////////////////////////////////////////////////////////////////////



\subsection{Sparse Octrees}
Für einige Anwendungen sind nur bestimmte Ausprägungen der in den Voxeln gespeicherten Werte von Interesse. Beispielsweise werden beim Iso-Surface-Rendering nur Voxel mit einem bestimmten Dichte\-werte als opake Oberfläche dargestellt. Werden nur diese Werte benötigt, kann die Datenstruktur weiter ausgedünnt werden, indem nur Voxel gespeichert werden, die zur Oberfläche beitragen.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.32\textwidth]{figures/cut_svo.pdf}
  \caption{Schnitt durch einen Sparse Voxel Octree \label{cut_svo}}
\end{figure}
Eine solche Volumenrepräsentation eignet sich ebenso zur Darstellung anderer opaker Oberflächen wie diskretisierter Dreiecksnetze, Punktwolken oder Höhenfeldern und wird als \textit{Sparse Octree} oder \textit{Sparse Voxel Octree} bezeichnet. Innere Knoten können dabei weniger als acht Kinder haben. Durch die variierende Anzahl von Kindknoten lässt sich keine implizite Regel zum Berechnen ihrer Positionen im Speicher herleiten. Vielmehr muss jeder Knoten speichern, welche Kindknoten besetzt sind und wo sich diese im Speicher befinden. Liegen die Kindknoten jedes Voxels jeweils hintereinander im Speicher, muss jedoch nur ein Verweis pro Elternknoten vorgehalten werden. Da in einem Sparse Voxel Octree nur Oberflächen gespeichert werden, steigt der Speicherbedarf mit jeder weiteren Tiefenstufe nur durchschnittlich um das vierfache, wie (vgl. ESVORG) zeigen konnte.


\subsection{Verwandte Arbeiten}


%  ////////////////////////////////////////////////////////////////////

\section{Raycasting von Volumendaten}
Bei Raycasting wird für jeden Punkt eines Ziel-Buffers ein Strahl erzeugt und mit den Volumendaten geschnitten. 
Volumen\-gitter können dazu beispielsweise in festen Abständen durchschritten werden, um Dichtewerte zu ermitteln und über eine Transfer\-funktion abzubilden (!!! ABBILDUNG FRONT-TO-BACK-VOLUME-RAYCASTING). Dabei müssen auch Bereiche des Volumens verarbeitet werden, die leer sind und nicht zum Bildinhalt beitragen.\\
In der Octree-Darstellung können große, homogen gefüllte Bereiche übersprungen werden. Dies wird erreicht, indem  der Strahl mit dem Voxel geschnitten wird, das diesen Bereich umgibt, um so ein Eintritts- sowie ein Austritts\-punkt zu ermitteln. Der hierarchische und reguläre Aufbau des Octrees ermöglicht es, die Anzahl der dazu notwendigen Schnitt\-berechnungen zu minimieren und diese effizient durchzuführen. Durch eine Tiefen\-suche im Baum kann in jeder Tiefe das den Strahl zuerst schneidende Voxel ermittelt werden. Da die Voxel ihre Position und Größe nur implizit über ihre Lage im Baum erhalten, müssen diese Werte beim Traversieren für jeden Voxel berechnet werden.\\
\\
Der Strahl kann durch $p_t(t)=p+td$ beschrieben werden. Löst man die Gleichung nach $t$ für eine achsen\-parallele Ebene, erhält man $t_x(x) = (\frac{1}{d_x})x+(\frac{-p_x}{d_x})$.

HIER NOCH SAGEN; WAS DAS TX(X) IST!!

\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/raycasting.pdf}
  \caption{Bestimmung der Reihenfolge der Kindknoten beim Schnitt \label{raycasting}}
\end{figure}




\subsection{Verwandte Arbeiten}


%  ////////////////////////////////////////////////////////////////////


\section{Out-of-Core Datenmanagement}
Out-of-Core-Strategien ermöglichen einer Anwendung oder einem System die Verwendung von Datenmengen, welche die lokale Speicherkapazität übersteigen. Voraussetzung dafür ist die Seg\-men\-tier\-bar\-keit der Daten. Außerdem muss die lokal gespeicherte Untermenge der segmentierten Daten zu jedem Zeitpunkt zur Verarbeitung genügen.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/out_of_core_principal.pdf}
  \caption{Out-Of-Core-Prinzip\label{out_of_core_principal}}
\end{figure}
\\
Die endliche Menge lokalen Speichers der GPU begrenzt die maximale Auflösung von SVO-Strukturen. Eine Vergrößerung des Speichers löst das Problem nicht nachhaltig. Wie oben beschrieben benötigt jede weitere SVO-Tiefe etwa die vierfache Speicher\-menge.\\
(!!! streaming system notwendig)\\
(beispiele für ooc Systeme)\\

\subsection{Verwandte Arbeiten}


%  ////////////////////////////////////////////////////////////////////




