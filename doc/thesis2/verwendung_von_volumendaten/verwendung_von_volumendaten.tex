\chapter{Repräsentation und Verwendung von Volumendaten in der Computergrafik}


\section{Volumendaten}

Volumendaten können durch dreidimensionale, äquidistante Gitter beschrieben werden. Die Kreuzungspunkte der Gitter werden \textit Voxel (Volumen-Pixel) genannt. Jeder Voxel kann einen einzelnen skalaren Wert, wie beispielsweise Dichte oder Druck, oder mehrere skalare Werte wie Farben und Richtungsinformationen enthalten. Dadurch eignet sich diese Darstellung zur Repräsentation eines äquidistant gesampelten Raumes, der nicht homogen gefüllt ist. Durch die uniforme Unterteilung des Raumes ist die Position und die Ausdehnung eines jeden Voxels implizit in der Datenstruktur enthalten und muss daher nicht gespeichert werden.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.32\textwidth]{figures/cut_volume.pdf}
  \caption{Schnitt durch ein Volumen Gitter \label{cut_volume}}
\end{figure}
Volumendaten werden vorwiegend in der Medizin, beispielsweise als Ausgabe der Magnet\-resonanz\-tomographie oder in der Geologie zum Abbilden der Ergebnisse von Reflexions\-seismik\-verfahren verwendet. Abbildung \ref{cut_volume} zeigt einen Schnitt durch einen Volumedatensatz.\\
Um eine hinreichende Auflösung der Volumenrepräsentation zu gewährleisten sind große Datenmengen erforderlich. Ein mit $512^3$ Voxeln aufgelöstes Volumen, dessen Voxel jeweils einen mit 4 Byte abgebildeten Skalar enthalten, belegt bereits 512 Megabyte. Verdoppelt man die Auflösung auf $1024^3$ Voxel, verachtfacht sich der Speicherbedarf auf 4 Gigabyte. Volumendaten enthalten in der Regel einen großen Anteil an homogenen Bereichen, die durch ein reguläres Gitter als viele Einzelwerte abgebildet werden müssen. Daher gibt es Datenstrukturen, die ausgehend von dem regulären Gitter eine hierarchische Struktur erzeugen, um diese Bereiche zusammenzufassen.

\subsubsection{}
\cite{Drebin:1988:VR:378456.378484}



%  ////////////////////////////////////////////////////////////////////


\subsection{Octrees}
Ein Octree ist eine raumteilende, rekursive Datenstruktur. Ein initiales, kubisches Volumen wird in acht gleich große Untervolumen geteilt. Die Teilung wird für jedes Untervolumen fortgeführt, bis eine maximale Tiefe, beziehungs\-weise ein maximaler Unterteilungsgrad erreicht ist. Mit jeder Tiefen\-stufe des Octrees verdoppelt sich die Auflösung der abbildbaren Information auf jeder Achse. Die Größe eines Voxels kann mit $ 2^{-d} $ bestimmt werden wobei $d$ die Tiefe des Voxels in der Baumstruktur, beginnend mit $d=0$ für die Wurzel, ist. Für vollbesetzte Octrees lässt sich eine Darstellungsvorschrift im Speicher aus der Struktur des Octrees ableiten. Da jeder Elternknoten genau acht Kinder besitzt, kann innerhalb einer seriellen Struktur implizit auf seine Kind\-knoten geschlossen werden. Die Positionen der Kinder eines Knotens kann durch die Funktion $ C(P,n) = 8*P+n $ berechnet werden, wobei $P$ der Index des Elternknotens, $n$ die Nummer des Kindes (beginnend mit 1) und das resultierende $C$ der Index des Kindknotens ist.\\ 
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.32\textwidth]{figures/cut_octree.pdf}
  \caption{Schnitt durch einen Octree \label{cut_octree}}
\end{figure}
Bereiche in Volumendaten, die homogene Daten enthalten oder leer sind, können von der Unterteilung ausgeschlossen werden, wodurch eine wesentlich kompaktere Darstellung der Daten gegenüber konventionellen Volumendaten erreicht werden kann. Dafür muss für jedes Voxel ein Verweis auf die ihn unterteilenden Untervolumen existieren. In der Regel besitzt jedes Voxel eines solchen Octrees acht Kinder (\textit{innerer Knoten}) oder kein Kind (\textit{Blatt-Knoten}). Die im ungünstigsten Fall zu speichernden sieben leere Knoten sind bei dieser Darstellung nötig um homogene Bereiche innerhalb des Eltern-Voxels zu kodieren. Abbildung \ref{cut_octree} zeigt einen Schnitt durch einen Octree der die Volumendaten aus Abbildung \ref{cut_volume} abbildet.\\ 
Jedes Voxel kann einen oder mehrere Skalare speichern. Oft werden diese Werte nicht direkt im Octree abgelegt, um bei die Traversierung der Struktur möglichst wenig Speicher auslesen zu müssen. Stattdessen werden die Attributwerte in einem zusätzlichen Attribut-Buffer abgelegt. In diesem wird für jedes Voxel im Octree ein Tupel mit Attributwerten vorgehalten. Die Attribute eines übergeordneten Voxels ergeben sich im einfachsten Fall aus dem Mittelwert der Attribute seiner untergeordneten Voxel, vergleichbar mit der Erzeugung von \textit{Mipmaps}. Somit enthält jedes Voxel seiner Größe entsprechend aufgelöste Attribut\-werte. Diese approximieren die Ausprägungen der Attribute innerhalb der räumlichen Ausdehnung des Voxels. Der Octree bildet also zugleich Geometrie und Textur ab. Der wesentliche Vorteil der Octree-Struktur gegenüber texturierten Dreiecksnetzen ist, dass sich mit dieser Struktur das LOD-Problem für Geometrie und Attribute (Texturen) gleichzeitig lösen lässt. Der hierarchische Aufbau und die Granularität von Octress ermöglichen eine effiziente Bestimmung der für die Darstellung optimalen Detailstufe der Daten. Dies kann während der Bildsynthese durch die Wahl der Traversierungstiefe im Baum pro Bildpunkt geschehen.

\subsubsection{Verwandte Arbeiten}
In \cite{Crassin2009} werden kleine Voxel-Volumen in einer Octree-Struktur angeordnet. Der Octree diente dabei zum effizienten Speichen von Volumendaten mit großen homogenen Bereichen. Um inhomogene Bereiche innerhalb der Volumendaten zu finden wurde der Octree mit den Sichtstrahlen geschnitten. Wurde solch ein Bereich gefunden wurde dessen Beitrag zum Bild durch Volumen-Raycasting bestimmt. Dazu wurde die hardwaregestützte, trilineare Filterung aktueller Grafikkarten ausgenutzt.



%  ////////////////////////////////////////////////////////////////////



\subsection{Sparse Octrees}
Für einige Anwendungen sind nur bestimmte Ausprägungen der in den Voxeln gespeicherten Werte von Interesse. Beispielsweise werden beim Iso-Surface-Rendering nur Voxel mit einem bestimmten Dichte\-werte als opake Oberfläche dargestellt. Werden nur diese Werte benötigt, kann die Datenstruktur weiter ausgedünnt werden, indem nur Voxel gespeichert werden, die zur Oberfläche beitragen.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.32\textwidth]{figures/cut_svo.pdf}
  \caption{Schnitt durch einen Sparse Voxel Octree \label{cut_svo}}
\end{figure}
Eine solche Volumenrepräsentation eignet sich ebenso zur Darstellung anderer opaker Oberflächen wie diskretisierter Dreiecksnetze, Punktwolken oder Höhenfeldern und wird als \textit{Sparse Octree} oder \textit{Sparse Voxel Octree} bezeichnet. Innere Knoten können dabei weniger als acht Kindknoten besitzen. Durch die variierende Anzahl von Kindknoten lässt sich keine implizite Regel zum Berechnen ihrer Positionen im Speicher herleiten. Vielmehr muss jeder Knoten speichern, welche Kindknoten besetzt sind und wo sich diese im Speicher befinden. Liegen die Kindknoten jedes Voxels jeweils hintereinander im Speicher, muss jedoch nur ein Verweis pro Elternknoten vorgehalten werden. Da in einem Sparse Voxel Octree nur Oberflächen gespeichert werden, steigt der Speicherbedarf mit jeder weiteren Tiefenstufe nur durchschnittlich um das vierfache, wie unter anderem in \cite{Laine2010} gezeigt werden konnte. Abbildung \ref{cut_svo} zeigt den Schnitt durch einen Sparse Voxel Octree der die Oberflächen der Volumendaten aus Abbildung \ref{cut_volume} speichert.
\\
\subsubsection{Verwandte Arbeiten}
In der Arbeit \cite{Plate2002} \citeauthor{Plate2002} wurden Sparse-Octrees verwendet, um Ober\-flächen\-normalen eines hoch\-auf\-gelösten Dreiecksnetzes zu speichern. Dabei wurde die Unterteilung der Knoten in Abhängigkeit von der Auflösung der Oberflächendetails vorangetrieben. Bei der Darstellung einer niedriger aufgelösten Version des Netzes wurden die im Octree enhaltenen Werte dazu verwendet, den ursprünglichen Detailgrad des Modells zu rekonstruieren. Diesen erhielt man während der Rekonstruktion durch Wahl der Octree-Tiefe in Abhängigkeit vom Abstand der Kamera zum betrachteten Objekt\-punkt. Dies führte zu einem mit dem Mipmapping vergleichbaren Ergebnis. Dabei verlangt dieser Ansatz keine Parametrisierung des Dreiecksnetzes.
\\
\\
\cite{Laine2010} stellt die bisher umfangreichste Arbeit über Sparse Voxel Octree Raycasting dar. Wie auch in \cite{Plate2002} speichert jeder Knoten im Octree einen Verweis auf den ersten Kindknoten und Bitmasken die die Konfiguration der möglichen Kindknoten beschreiben. Neben einem sehr effizienten Raycasting-Ansatz beschreibt die Arbeit unter anderem Techniken zur Kompression von Normalenwerten und der Nutzung von Konturinformation zur besseren Approximation des Oberflächen\-verlaufs der dargestellten Geometrie. Zusätzlich beschreibt die Arbeit einen effizienten Out-of-Core Ansatz. Im Gegensatz zu dem in der vorliegenden Arbeit beschriebenen Out-of-Core-Ansatz, arbeitet dieser ausschließlich cpu-seitig. Dabei wird eine Heuristig verwendet um anhand der Auflösung der bisher geladenen Segmente und der aktuellen Ansicht, mögliche neu Segmente anzufordern.
\\
\\
In der Arbeit von \cite{CNSGE11b} wird ein dynamisch erstellte Sparse-Voxel-Octree-Representation der Szenengeometrie verwendet um globale Beleuchtungswerte für alle Oberflächen zu speichen. Wärend der Bilderzeugung durch Rasterisierug konnten damit durch Verwendung von Cone Tracing zwei Reflexiontiefen für den direktionalen Lichtanteil in echtzeitfähigen Bildwiederholraten berechnet werden. Um auch dynamische Dreiecksnetze unterstützen zu können wurde die Octree-Repräsentation der Szenengeometrie für jedes Bild neu erstellt.


%  ////////////////////////////////////////////////////////////////////


\section{Raycasting von Volumendaten}
Bei Raycasting wird für jeden Punkt eines Ziel-Buffers ein Strahl erzeugt und mit den Volumendaten geschnitten. 
Volumen\-gitter können dazu beispielsweise in festen Abständen durchschritten werden, um Dichtewerte zu ermitteln und über eine Transfer\-funktion abzubilden (!!! ABBILDUNG FRONT-TO-BACK-VOLUME-RAYCASTING). Dabei müssen auch Bereiche des Volumens verarbeitet werden, die leer sind und nicht zum Bildinhalt beitragen.\\
In der Octree-Darstellung können große, homogen gefüllte Bereiche übersprungen werden. Dies wird erreicht, indem  der Strahl mit dem Voxel geschnitten wird, das diesen Bereich umgibt, um so ein Eintritts- sowie ein Austritts\-punkt zu ermitteln. Der hierarchische und reguläre Aufbau des Octrees ermöglicht es, die Anzahl der dazu notwendigen Schnitt\-berechnungen zu minimieren und diese effizient durchzuführen. Durch eine Tiefen\-suche im Baum kann in jeder Tiefe das den Strahl zuerst schneidende Voxel ermittelt werden. Da die Voxel ihre Position und Größe nur implizit über ihre Lage im Baum erhalten, müssen diese Werte beim Traversieren für jeden Voxel berechnet werden.\\
\\
Ein Strahl kann durch $p_t(t)=p+td$ beschrieben werden. Löst man die Gleichung nach $t$ für eine achsen\-parallele Ebene, erhält man $t_x(x) = (\frac{1}{d_x})x+(\frac{-p_x}{d_x})$. Die Werte für  $\frac{1}{d_x}$ und $\frac{-p_x}{d_x}$ können für jeden Strahl vorberechnet werden wodurch sich der Schnitt zwischen Strahl und Ebene auf eine Multiplikation und eine Addition reduzieren lässt. Abbildung \ref{raycasting} zeigt auf der linken Seite den Schnitt eines Strahles mit den achenparallelen Ebenen der Kindknoten bei $x_0$, $x_1$, $x_1$, $y_1$. Der Eintrittspunkt des Strahls in den Elternknoten kann über die Länge $t_min = max(t_x(x0),t_x(y0),t_x(z0)$ berechnet werden. Der Austrittspunkt kann durch Einsetzen von $t_max = min(t_x(x1),t_x(y1),t_x(z1)$ in die Strahlgleichung berechnet werden.\\
Da beim Raycasting der erste


\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/raycasting.pdf}
  \caption{Bestimmung der Reihenfolge der Kindknoten beim Schnitt \label{raycasting}}
\end{figure}




\subsubsection{Verwandte Arbeiten}



%  ////////////////////////////////////////////////////////////////////




