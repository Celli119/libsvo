\chapter{Repräsentation und Verwendung von Volumendaten in der Computergrafik}


\section{Volumendaten}

Volumendaten können durch dreidimensionale, äquidistante Gitter beschrieben werden. Die Kreuzungspunkte der Gitter werden \textit Voxel (Volumen-Pixel) genannt. Jeder Voxel kann einen einzelnen skalaren Wert, wie beispielsweise Dichte oder Druck, oder mehrere skalare Werte wie Farben und Richtungsinformationen enthalten. Dadurch eignet sich diese Darstellung zur Repräsentation eines äquidistant gesampelten Raumes, der nicht homogen gefüllt ist. Durch die uniforme Unterteilung des Raumes ist die Position und die Ausdehnung eines jeden Voxels implizit in der Datenstruktur enthalten und muss daher nicht gespeichert werden.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.32\textwidth]{figures/cut_volume.pdf}
  \caption{Schnitt durch ein Volumen Gitter \label{cut_volume}}
\end{figure}
Volumendaten werden vorwiegend in der Medizin, beispielsweise als Ausgabe der Magnet\-resonanz\-tomographie oder in der Geologie zum Abbilden der Ergebnisse von Reflexions\-seismik\-verfahren verwendet.\\
Um eine hinreichende Auflösung der Volumenrepräsentation zu gewährleisten sind große Datenmengen erforderlich. Ein mit $512^3$ Voxeln aufgelöstes Volumen, dessen Voxel jeweils einen mit 4 Byte abgebildeten Skalar enthalten, belegt bereits 512 Megabyte. Verdoppelt man die Auflösung auf $1024^3$ verachtfacht sich der Speicherbedarf auf 4 Gigabyte. Volumendaten enthalten in der Regel einen großen Anteil an homogenen Bereichen die durch ein reguläres Gitter als viele Einzelwerte abgebildet werden müssen. Daher gibt es Datenstrukturen die ausgehend von dem regulären Gitter eine hierarchische Struktur erzeugen, um diese Bereiche zusammenzufassen.



%  ////////////////////////////////////////////////////////////////////


\subsection{Octrees}
Ein Octree ist eine raumteilende, rekursive Datenstruktur. Ein initiales, kubisches Volumen wird in acht gleich große Untervolumen geteilt. Die Teilung wird für jedes Untervolumen fortgeführt, bis eine maximale Tiefe beziehungs\-weise ein maximaler Unterteilunggrad erreicht ist. Mit jeder Tiefen\-stufe des Octrees verdoppelt sich die Auflösung der abbildbaren Information auf jeder Achse. Die Größe eines Voxels kann mit $ 2^{-d} $ bestimmt werden wobei $d$ die Tiefe des Voxels in der Baumstruktur, beginnend mit $d=0$ für die Wurzel, ist. Für vollbesetzte Octrees ist eine Darstellung im Speicher implizit vorgegeben. Da jeder Elternknoten genau acht Kinder besitzt, kann innerhalb einer seriellen Struktur implizit auf seine Kind\-knoten geschlossen werden. Die Positionen der Kinder eines Knotens kann durch die Funktion $ C(P,n) = 8*P+n $ berechnet werden wobei $P$ der Index des Elternknotens, $n$ die Nummer des Kindes (beginnend mit 1) und das resultierende $C$ der Index des Kindknotens ist.\\
\\
Bereiche in Volumendaten die homogene Daten enthalten oder leer sind, können jedoch von der Unterteilung ausgeschlossen werden, wodurch eine wesentlich kompaktere Darstellung der Daten gegenüber konventionellen Volumendaten erreicht werden kann. Dafür muss für jedes Voxel ein Verweis auf die ihn unterteilenden Untervolumen existieren. In der Regel besitzt jedes Voxel eines solchen Octrees acht Kinder (\textit{innerer Knoten}) oder kein Kind (\textit{Blatt-Knoten}). Die, im ungünstigsten Fall zu speichernden sieben leeren Knoten, sind bei dieser Darstellung nötig, um homogene Bereiche innerhalb des Eltern-Voxels zu kodieren.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.32\textwidth]{figures/cut_octree.pdf}
  \caption{Schnitt durch einen Octree \label{cut_octree}}
\end{figure}
Jeder Voxel kann ein oder mehrere Skalare speichern. Oft werden diese Werte nicht direkt im Octree abgelegt um bei die Traversierung der Struktur möglichst wenig Speicher lesen zu müssen. Stattdessen werden die Attributinformation in einem zusätzlichen Attribut-Buffer abgelegt, in dem zu jeder Voxel-Position im Octree ein Tuple mit Attributinformation an der selben Stelle im Attribut-Buffer vorgehalten wird. Die Attribute eines übergeordneten Voxels ergeben sich im einfachsten Fall aus dem Mittel der Attribute seiner untergeordneten Voxel, vergleichbar mit der Erzeugung von \textit{Mipmaps}. Somit enthält jedes Voxel eine seiner Größe entsprechend aufgelöste Attribut\-information. Diese approximiert die Ausprägungen der Attribute in seinem Bereich. Der Octree ist also beides: Geometrie und Textur. Der wesentliche Vorteil der Octree-Struktur gegenüber texturierten Dreiecksnetzen ist, dass sich mit ihr das LOD-Problem für Attribute (Texturen) und Geometrie gemeinsam lösen lässt. Dies kann während der Bildsynthese durch die Wahl der Traversierungstiefe im Baum pro Bildpunkt geschehen.

\subsection{Verwandte Arbeiten}



%  ////////////////////////////////////////////////////////////////////



\subsection{Sparse Octrees}
Für einige Anwendungen sind nur bestimmte Ausprägungen der in den Voxeln gespeicherten Werte von Interesse. Beispielsweise werden beim Iso-Surface-Rendering nur Voxel mit einem bestimmten Dichtewert als opake Oberfläche dargestellt. Werden nur diese Werte benötigt, kann die Datenstruktur weiter ausgedünnt werden, in dem nur noch Voxel gespeichert werden die zur Oberfläche beitragen.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.32\textwidth]{figures/cut_svo.pdf}
  \caption{Schnitt durch einen Sparse Voxel Octree \label{cut_svo}}
\end{figure}
Eine solche Volumenrepräsentation eignet sich ebenso zur Darstellung anderer opaker Oberflächen wie diskretisierte Dreiecksnetze, Punktwolken oder Höhenfelder und wird als \textit{Sparse Octree} oder \textit{Sparse Voxel Octree} bezeichnet. Dazu ist es erforderlich, dass innere Knoten weniger als acht Kinder haben können. Durch die variierende Anzahl von Kindknoten existiert keine implizite Regel zum berechnen deren Positionen im Speicher. Vielmehr muss jeder Knoten speichern welche Kindknoten vorhanden sind und wo sich diese im Speicher befinden. Liegen die Kindknoten jedes Voxels jeweils hintereinander im Speicher, muss jedoch nur ein Verweis pro Elternknoten vorgehalten werden. Da in einem Sparse Voxel Octree nur Oberflächen gespeichert werden, steigt der Speicherbedarf pro weiterer Tiefenstufe nur durchschnittlich um das vierfache, wie (vgl. ESVORG) zeigen konnte.


\subsection{Verwandte Arbeiten}


%  ////////////////////////////////////////////////////////////////////

\section{Raycasting von Volumendaten}
Bei Raycasting wird für jeden Punkt eines Ziel-Buffers ein Strahl erzeugt und mit den Volumendaten geschnitten. 
Volumen\gitter können dazu beispielsweise in festen Abständen durchschritten werden um Dichtewerte zu ermitteln und über eine Transfer\-funktion abzubilden (!!! ABBILDUNG FRONT-TO-BACK-VOLUME-RAYCASTING). Dabei müssen auch Bereiche des Volumens verarbeitet werden die leer sind und nicht zum Bildinhalt beitragen.\\
In der Octree-Darstellung können große homogen gefüllte Bereiche übersprungen werden. Dies wird erreicht indem  der Strahl mit dem Voxeln geschnitten wird der diesen Bereich umgibt um so ein Eintritts- sowie ein Austrittspunkt zu ermitteln. Der hierarchischeund regulären Aufbau des Octrees ermöglicht es die dazu notwendigen Schnitt\-berechnung zu minimieren und effizient durchzuführen. Durch eine Tiefensuche im Baum kann in jeder Tiefe das Voxel ermittelt werden, das den Strahl zuerst scheidet. Da die Voxel ihre Position und Größe nur implizit über ihrer Lage im Baum speichern müsse diese beim Traversieren für jeden Voxel erzeugt werden.\\
\\
Der Strahl kann durch $p_t(t)=p+td$ beschrieben werden. Löst man die Gleichung nach $t$ für eine achsen\-parallele Ebene erhält man $t_x(x) = (\frac{1}{d_x})x+(\frac{-p_x}{d_x})$.







\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/raycasting.pdf}
  \caption{Schnitt durch einen Sparse Voxel Octree \label{cut_svo}}
\end{figure}

\subsection{Verwandte Arbeiten}


%  ////////////////////////////////////////////////////////////////////

\section{Out-of-Core Datenmanagement}
Out-of-Core-Strategien ermöglichen einer Anwendung oder einem System die Verwendung von Datenmengen, welche die lokale Speicherkapazität übersteigen. Voraussetzung dafür ist die Seg\-men\-tier\-bar\-keit der Daten. Außerdem muss die lokal gespeicherte Untermenge der segmentierten Daten zu jedem Zeitpunkt zur Verarbeitung genügen.
\begin{figure}[position=h]
  \centering
  \includegraphics[width=0.75\textwidth]{figures/out_of_core_principal.pdf}
  \caption{Out-Of-Core-Prinzip\label{out_of_core_principal}}
\end{figure}
\\
Die endliche Menge lokalen Speichers der GPU begrenzt die maximale Auflösungen der SVO-Struktur. Eine Vergrößerung des Speichers löst das Problem nicht da wie oben beschrieben eine weitere SVO-Tiefe etwa die vierfache Speicher\-menge benötigt.\\
(!!! streaming system notwendig)\\
(beispiele für ooc Systeme)\\

\subsection{Verwandte Arbeiten}


%  ////////////////////////////////////////////////////////////////////




