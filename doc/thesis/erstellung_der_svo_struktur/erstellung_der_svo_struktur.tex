\chapter{Erstellung der SVO-Struktur}


\section{Ein generalisiertes System zur SVO-Erstellung}
Das System zur Erstellung der SVO-Struktur ist modular aufgebaut und besteht prinzipiell aus drei Teilen: Dem \textbf{\textit{Build-Manager}} der den Ablauf der SVO-Generierung steuert, einem \textbf{\textit{Treelet-Builder}} der die Treelets erstellt und abhängig vom Typ der Eingabedaten gewählt wird und einem \textbf{\textit{Attributgenerator}} der Abhängig von Eingabedaten und gewünschter Attributkonfiguration der Ausgabedaten gewählt werden kann. Mit dieser Unterteilung des Systems ist es prinzipiell möglich verschiedenste Eingabedaten wie 3D-Objekte aus Dreiecksnetzen oder Punktwolken zu verarbeiten und eine Vielzahl von Attributtkonfigurationen zu erstellen. Durch den modularen Aufbau und der Bereitstellung entsprechender Basisklassen ist es möglich Unterstützung für weitere Eingabeformate zu schaffen.


\section{Erzeugung der Treelet Struktur}
Die SVO-Struktur wird schon bei der Erstellung segmentiert, das heißt, in Treelets unterteilt aufgebaut. Dies bietet die Möglichkeit bereits erzeugte Treelets auf die Festplatte auszulagern, sollte der Arbeitsspeicher nicht aussreichen um die erzeugten Daten zu halten.\\
Als Eingabe werden zunächst die gewünschte, minimale Tiefe des resultierenden Octrees, die Speichergröße der Treelets und der Pfad zu den Ausgangsdaten benötigt. Der Build-Manager erstellt zunächst ein initiales, leeres Treelet (\textit{Wurzel-Treelet}) und übergibt dieses zusammen mit den Eingabeparametern und den Ausgangsdaten an den Treelet-Builder. Dieser füllt das Treelet anhand der Eingabedaten. Dabei werden alle entstandenen Blatt-Knoten, die noch nicht die gewünschte, minimale Tiefe in der Octree-Struktur aufweisen, notiert. Zu jedem dieser Blattknoten wird unter Anderem seine Tiefe, seine Transformation relativ zum Wurzelknoten und eine Liste der Primitive der Ausgangsdaten gespeichert, die in diesem Blattknoten liegen. Ausserdem wird jeweils der Treelet-Index, der Index des Blattknotens und dessen Elternknotens gespeichert um die Verknüpfung der folgenden Treelets realisieren zu können (vgl. Segmentierung !!!).\\
Der Build-Manager speichert diese Informationen in einer Queue und erzeugt für jeden Eintrag ein neues Treelet (\textit{Top-Down}). Diese werden durch die gespeicherten Treelet- und Blattknotenindices des Wurzel-Treelets initialisiert und sind so logisch mit diesem verbunden. Jedes dieser Treelets wird wiederum dem Treelet-Builder übergeben, der sie anhand der jeweiligen Untermenge der Primitive und der gespeicherten Transformation des zugrundeliegenden Blatt\-knotens füllt.\\
Der Build-Manager erzeugt sukzessiv weitere Treelets für alle Blattknoten bereits erstellter Treelets bis die geforderte minimale Tiefe des Octrees für alle Blattknoten erreicht ist. Für Blattknoten die diese Tiefe erreicht haben, erzeugt ein Attributgenerator anhand deren Transformation und Primitivliste die gewünschten Attribute. Die Liste der jeweils beteiligten Primitive und alle weiteren Informationen die zur Erstellung weiterer Treelets benötigt würden können an dieser Stelle gelöscht werden.\\
Ist die Erstellung der Treelets abgeschlossen werden die Attribute der inneren Knoten durch Mitteln der Attribute ihrer Untergeordneten Knoten erstellt. Dies geschiet für alle Treelets in umgekehrter Reihenfolge ihrer Erstellung (\textit{Bottom-Up}). So wird sichergestellt, dass der Wurzelknoten eines Untergeordneten Treelets bereits Attributinformation enthält wenn sein Übergeordnetes Treelet diese zur Generierung seiner Attribute in seinen Blattknoten benötigt.\\
Ist die Erstellung der Attribute bis in den Wurzelknoten des Wurzel-Treelets vorangeschritten ist die Erstellung des Octrees abgeschlossen. 


\section{Arbeitsweise des Treelet-Builders}
Der Treelet-Builder erstellt die Knoten in der Breite (\textit{Breadth-First}) und arbeitet daher intern auf einem FIFO-Kontainer (\textit{Queue}). Der Aufbau eines Elementes dieses Queue ist im Listing \ref{lst:queueelement} zu sehen. Jedes Element der Queue entspricht einem Knoten in der SVO-Struktur und enthält einerseits alle Informationen die nötig sind diesen Knoten seinem übergeordneten Knoten mitzuteilen und andererseits die Erzeugung weiterer Unterknoten zu ermöglichen.

%\begin{figure}[position=h width=0.75\textwidth]
%  \centering
\begin{lstlisting}[caption={Queue-Element},label={lst:queueelement}]
struct QueueElement
{
  // Knoten-Index des Knotens innerhalb des Treelets
  unsigned              _localLeafIndex;         
  // Kind-Index des Knotens innerhalb seines Eltern-Knotens
  char                  _idx;                    
  // Knoten-Index des Eltern-Knotens
  unsigned              _parentLocalNodeIndex;   
  // Tiefe des Knotens in der SVO-Struktur
  unsigned              _depth;                  
  // Transformation des Knotens relativ zum Wurzelknoten
  gloost::Matrix        _aabbTransform;          
  // In diesem Knoten enthaltene Primitive der Ausgangsdaten
  std::vector<unsigned> _primitiveIds;           
};
\end{lstlisting}
%\end{figure}
Initial wird ein Queue-Element stellvertretend für den Wurzelknoten des aktuellen Treelets erstellt. Dieses enhält die relative Transformation dieses Knotens in der SVO-Struktur sowie alle Primitive die in diesen Knoten fallen. Für jeden potentiellen Kind-Knoten wird ein Queue-Element mit entsprechenden Parametern erzeugt und dessen \textit{Bounding Box} mit den Primitiven des aktuellen Queue-Elementes zum Schnitt gebracht. Dabei wird für jedes Kind die Untermenge an Primitiven notiert die geschnitten wurden. Falls ein Kind keine Primitive enthält, wird es verworfen. Die restlichen Kinder bekommen aufeinanderfolgende Positionen innerhalb des aktuellen Treelets. Der \textit{First-Child-Index} des Knotens des aktuellen Queue-Elementes wird daraufhin auf die Position des ersten Kindes gesetzt. Die Queue-Elemente der Kinder werden nun in die Queue eingereiht.\\
Vor dem Abarbeiten eines Queue-Elementes wird überprüft, ob noch genügend freie Plätze für die maximal mögliche Anzahl für Unterteilungen in Kind-Knoten im Treelet vorhanden sind. Sind also weniger als acht freie Plätze verfügbar gilt das Treelet als voll. 
Ist dies der Fall werden die in der Queue enthaltenen Elemente, nach ihrer Tiefe in der SVO-Struktur, in finale und weiter zu unterteilende Elemente getrennt und in zwei Kontainern im Treelet gespeichert. Nachdem die finalen Knoten in ihren Eltern-Knoten als solche markiert wurden, wird das Treelet an den Build-Manager zurückgegeben.\\
Der Build-Manager erzeugt für jedes nicht finale Queue-Element ein weiteres Treelet. Der Index jedes Treelets wird im \textit{First-Child-Index} des zugehörigen Blattknotens im übergeordneten Treelet gespeichert. Dann werden die Treelets entsprechned parametrisiert in einer eigenen Queue eingereiht um sie in entsprechender Reihenvolge an den Treelet-Builder weitergeben zu können. Der oben beschriebene Ablauf wiederholt sich daraufhin für jedes Treelet in der Queue. Liefert der Treelet-Builder nur noch Treelets mit finalen Blattknoten, leert sich die Queue und das Erstellen der SVO-Struktur ist abgeschlossen. 


\section{Attribut-Generation}
Zu jedem Treelet werden parallel ein oder mehrere Buffer mit verschachtelten (\textit{interleaved}) Attributinformationen erstellt (!!! BILD interleaved Attributes). Anzahl und Layout der Attribut-Buffer sind abhängig vom gewählten Attribut-Generator.\\
Für jeden finalen Blatt-Knoten wird mit Hilfe der gespeicherten Primitiven und Transformation eine Menge von Attributen erzeugt. Dieser Vorgang soll im Folgenden anhand von Dreiecksprimitiven erläutert werden. Für jedes Dreieck innerhalb eines Blatt-Knotens wird ein Strahl erzeugt, der durch die Voxelmitte und senkrecht zum Dreieck verläuft (!!! siehe Hennings grafik). Nun kann jeweils eine UV-Koordinate ermittelt werden indem der Strahl mit dem jeweiligen Dreick geschnitten wird. Durch die Wahl der Richtung ist gewährleistet, dass der Winkel zwischen Strahl und Dreicksnormale maximal ist, so dass die Wahrscheinlichkeit eines Schnittes erhöht wird. Trotzdem ist es möglich, dass der Strahl das Dreieck verfehlt, da das Dreick den Voxel beispielsweise nur in einer Ecke schneidet. Dabei treten für U und V Werte auf, die negativ oder größer als eins sind. In diesem Fall werden die Werte künstlich auf den zulässigen Bereich beschränkt. Dieser Trick erzeugt ein Rauschen in den Daten das aber angesichts der geringen Größe der Blatt-Knoten und des daraus resultierenden geringen Fehlers nicht sichtbar ist.\\
Mit Hilfe der ermittelten UV-Koordinaten können nun Attribute wie Farbe, Normale oder Texturekoordinate aus den Vertexattributen des Dreiecks trilinear interpoliert werden. Die erhaltenen Werte werden über alle am Voxel beteiligten Dreiecke hinweg gemittelt.  
Die daraus resultierenden Farb- und Normalenwerte werden auf 8 bit pro Komponente quantisiert bevor sie in den Attributbuffer gespeichert werden. 






